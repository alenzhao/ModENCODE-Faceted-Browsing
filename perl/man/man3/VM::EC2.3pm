.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "VM::EC2 3pm"
.TH VM::EC2 3pm "2011-09-26" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
VM::EC2 \- Control the Amazon EC2 and Eucalyptus Clouds
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # set environment variables EC2_ACCESS_KEY, EC2_SECRET_KEY and/or EC2_URL
\& # to fill in arguments automatically
\&
\& ## IMAGE AND INSTANCE MANAGEMENT
\& # get new EC2 object
\& my $ec2 = VM::EC2\->new(\-access_key => \*(Aqaccess key id\*(Aq,
\&                        \-secret_key => \*(Aqaws_secret_key\*(Aq,
\&                        \-endpoint   => \*(Aqhttp://ec2.amazonaws.com\*(Aq);
\&
\& # fetch an image by its ID
\& my $image = $ec2\->describe_images(\*(Aqami\-12345\*(Aq);
\&
\& # get some information about the image
\& my $architecture = $image\->architecture;
\& my $description  = $image\->description;
\& my @devices      = $image\->blockDeviceMapping;
\& for my $d (@devices) {
\&    print $d\->deviceName,"\en";
\&    print $d\->snapshotId,"\en";
\&    print $d\->volumeSize,"\en";
\& }
\&
\& # run two instances
\& my @instances = $image\->run_instances(\-key_name      =>\*(AqMy_key\*(Aq,
\&                                       \-security_group=>\*(Aqdefault\*(Aq,
\&                                       \-min_count     =>2,
\&                                       \-instance_type => \*(Aqt1.micro\*(Aq)
\&           or die $ec2\->error_str;
\&
\& # wait for both instances to reach "running" or other terminal state
\& $ec2\->wait_for_instances(@instances);
\&
\& # print out both instance\*(Aqs current state and DNS name
\& for my $i (@instances) {
\&    my $status = $i\->current_status;
\&    my $dns    = $i\->dnsName;
\&    print "$i: [$status] $dns\en";
\& }
\&
\& # tag both instances with Role "server"
\& foreach (@instances) {$_\->add_tag(Role=>\*(Aqserver\*(Aq);
\&
\& # stop both instances
\& foreach (@instances) {$_\->stop}
\& 
\& # find instances tagged with Role=Server that are
\& # stopped, change the user data and restart.
\& @instances = $ec2\->describe_instances({\*(Aqtag:Role\*(Aq       => \*(AqServer\*(Aq,
\&                                        \*(Aqrun\-state\-name\*(Aq => \*(Aqstopped\*(Aq});
\& for my $i (@instances) {
\&    $i\->userData(\*(AqSecure\-mode: off\*(Aq);
\&    $i\->start or warn "Couldn\*(Aqt start $i: ",$i\->error_str;
\& }
\&
\& # create an image from both instance, tag them, and make
\& # them public
\& for my $i (@instances) {
\&     my $img = $i\->create_image("Autoimage from $i","Test image");
\&     $img\->add_tags(Name  => "Autoimage from $i",
\&                    Role  => \*(AqServer\*(Aq,
\&                    Status=> \*(AqProduction\*(Aq);
\&     $img\->make_public(1);
\& }
\&
\& ## KEY MANAGEMENT
\&
\& # retrieve the name and fingerprint of the first instance\*(Aqs 
\& # key pair
\& my $kp = $instances[0]\->keyPair;
\& print $instances[0], ": keypair $kp=",$kp\->fingerprint,"\en";
\&
\& # create a new key pair
\& $kp = $ec2\->create_key_pair(\*(AqMy Key\*(Aq);
\& 
\& # get the private key from this key pair and write it to a disk file
\& # in ssh\-compatible format
\& my $private_key = $kp\->private_key;
\& open (my $f,\*(Aq>MyKeypair.rsa\*(Aq) or die $!;
\& print $f $private_key;
\& close $f;
\&
\& # Import a preexisting SSH key
\& my $public_key = \*(Aqssh\-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC8o...\*(Aq;
\& $key = $ec2\->import_key_pair(\*(AqNewKey\*(Aq,$public_key);
\&
\& ## SECURITY GROUPS AND FIREWALL RULES
\& # Create a new security group
\& my $group = $ec2\->create_security_group(\-name        => \*(AqNewGroup\*(Aq,
\&                                         \-description => \*(Aqexample\*(Aq);
\&
\& # Add a firewall rule 
\& $group\->authorize_incoming(\-protocol  => \*(Aqtcp\*(Aq,
\&                            \-port      => 80,
\&                            \-source_ip => [\*(Aq192.168.2.0/24\*(Aq,\*(Aq192.168.2.1/24\*(Aq});
\&
\& # Write rules back to Amazon
\& $group\->update;
\&
\& # Print current firewall rules
\& print join ("\en",$group\->ipPermissions),"\en";
\&
\& ## VOLUME && SNAPSHOT MANAGEMENT
\&
\& # find existing volumes that are available
\& my @volumes = $ec2\->describe_volumes({status=>\*(Aqavailable\*(Aq});
\&
\& # back \*(Aqem all up to snapshots
\& foreach (@volumes) {$_\->snapshot(\*(AqBackup on \*(Aq.localtime)}
\&
\& # find a stopped instance in first volume\*(Aqs availability zone and 
\& # attach the volume to the instance using /dev/sdg
\& my $vol  = $volumes[0];
\& my $zone = $vol\->availabilityZone;
\& @instances = $ec2\->describe_instances({\*(Aqavailability\-zone\*(Aq=> $zone,
\&                                        \*(Aqrun\-state\-name\*(Aq   => $stopped);
\& $instances[0]\->attach_volume($vol=>\*(Aq/dev/sdg\*(Aq) if @instances;
\&
\& # create a new 20 gig volume
\& $vol = $ec2\->create_volume(\-availability_zone=> \*(Aqus\-east\-1a\*(Aq,
\&                            \-size             =>  20);
\& $ec2\->wait_for_volumes($vol);
\& print "Volume $vol is ready!\en" if $vol\->current_status eq \*(Aqavailable\*(Aq;
\&
\& # create a new elastic address and associate it with an instance
\& my $address = $ec2\->allocate_address();
\& $instances[0]\->associate_address($address);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an interface to the 2011\-05\-15 version of the Amazon \s-1AWS\s0 \s-1API\s0
(http://aws.amazon.com/ec2). It was written provide access to the new
tag and metadata interface that is not currently supported by
Net::Amazon::EC2, as well as to provide developers with an extension
mechanism for the \s-1API\s0. This library will also support the Eucalyptus
open source cloud (http://open.eucalyptus.com).
.PP
The main interface is the \s-1VM::EC2\s0 object, which provides methods for
interrogating the Amazon \s-1EC2\s0, launching instances, and managing
instance lifecycle. These methods return the following major object
classes which act as specialized interfaces to \s-1AWS:\s0
.PP
.Vb 12
\& VM::EC2::BlockDevice               \-\- A block device
\& VM::EC2::BlockDevice::Attachment   \-\- Attachment of a block device to an EC2 instance
\& VM::EC2::BlockDevice::EBS          \-\- An elastic block device
\& VM::EC2::BlockDevice::Mapping      \-\- Mapping of a virtual storage device to a block device
\& VM::EC2::BlockDevice::Mapping::EBS \-\- Mapping of a virtual storage device to an EBS block device
\& VM::EC2::Group                     \-\- Security groups
\& VM::EC2::Image                     \-\- Amazon Machine Images (AMIs)
\& VM::EC2::Instance                  \-\- Virtual machine instances
\& VM::EC2::Instance::Metadata        \-\- Access to runtime metadata from running instances
\& VM::EC2::Region                    \-\- Availability regions
\& VM::EC2::Snapshot                  \-\- EBS snapshots
\& VM::EC2::Tag                       \-\- Metadata tags
.Ve
.PP
In addition, there are several utility classes:
.PP
.Vb 6
\& VM::EC2::Generic                   \-\- Base class for all AWS objects
\& VM::EC2::Error                     \-\- Error messages
\& VM::EC2::Dispatch                  \-\- Maps AWS XML responses onto perl object classes
\& VM::EC2::ReservationSet            \-\- Hidden class used for describe_instances() request;
\&                                               The reservation Ids are copied into the Instance
\&                                               object.
.Ve
.PP
The interface provided by these modules is based on that described at
http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/. The
following caveats apply:
.PP
.Vb 4
\& 1) Not all of the Amazon API is currently implemented. Specifically,
\&    calls dealing with Virtual Private Clouds (VPC), cluster management,
\&    and spot instances are not currently supported.
\&    See L</MISSING METHODS> for a list of all the unimplemented API calls. 
\&
\& 2) For consistency with common Perl coding practices, method calls
\&    are lowercase and words in long method names are separated by
\&    underscores. The Amazon API prefers mixed case.  So in the Amazon
\&    API the call to fetch instance information is "DescribeInstances",
\&    while in VM::EC2, the method is "describe_instances". To avoid
\&    annoyance, if you use the mixed case form for a method name, the
\&    Perl autoloader will automatically translate it to underscores for
\&    you, and vice\-versa; this means you can call either
\&    $ec2\->describe_instances() or $ec2\->DescribeInstances().
\&
\& 3) Named arguments passed to methods are all lowercase, use
\&    underscores to separate words and start with hyphens.
\&    In other words, if the AWS API calls for an argument named
\&    "InstanceId" to be passed to the "DescribeInstances" call, then
\&    the corresponding Perl function will look like:
\&
\&         $instance = $ec2\->describe_instances(\-instance_id=>\*(Aqi\-12345\*(Aq)
\&
\&    In most cases automatic case translation will be performed for you
\&    on arguments. So in the previous example, you could use
\&    \-InstanceId as well as \-instance_id. The exception
\&    is when an absurdly long argument name was replaced with an 
\&    abbreviated one as described below. In this case, you must use
\&    the documented argument name.
\&
\&    In a small number of cases, when the parameter name was absurdly
\&    long, it has been abbreviated. For example, the
\&    "Placement.AvailabilityZone" parameter has been represented as
\&    \-placement_zone and not \-placement_availability_zone. See the
\&    documentation for these cases.
\&
\& 4) For each of the describe_foo() methods (where "foo" is a type of
\&    resource such as "instance"), you can fetch the resource by using
\&    their IDs either with the long form:
\&
\&          $ec2\->describe_foo(\-foo_id=>[\*(Aqa\*(Aq,\*(Aqb\*(Aq,\*(Aqc\*(Aq]),
\&
\&    or a shortcut form: 
\&
\&          $ec2\->describe_foo(\*(Aqa\*(Aq,\*(Aqb\*(Aq,\*(Aqc\*(Aq);
\&
\& 5) When the API calls for a list of arguments named Arg.1, Arg.2,
\&    then the Perl interface allows you to use an anonymous array for
\&    the consecutive values. For example to call describe_instances()
\&    with multiple instance IDs, use:
\&
\&       @i = $ec2\->describe_instances(\-instance_id=>[\*(Aqi\-12345\*(Aq,\*(Aqi\-87654\*(Aq])
\&
\& 6) All Filter arguments are represented as a \-filter argument whose value is
\&    an anonymous hash:
\&
\&       @i = $ec2\->describe_instances(\-filter=>{architecture=>\*(Aqi386\*(Aq,
\&                                               \*(Aqtag:Name\*(Aq  =>\*(AqWebServer\*(Aq})
\&
\&    If there are no other arguments you wish to pass, you can omit the
\&    \-filter argument and just pass a hashref:
\&
\&       @i = $ec2\->describe_instances({architecture=>\*(Aqi386\*(Aq,
\&                                      \*(Aqtag:Name\*(Aq  =>\*(AqWebServer\*(Aq})
\&
\&    For any filter, you may represent multiple OR arguments as an arrayref:
\&
\&      @i = $ec2\->describe\-instances({\*(Aqinstance\-state\-name\*(Aq=>[\*(Aqstopped\*(Aq,\*(Aqterminated\*(Aq]})
\&
\&    When adding or removing tags, the \-tag argument uses the same syntax.
\&
\& 7) The tagnames of each XML object returned from AWS are converted into methods
\&    with the same name and typography. So the <privateIpAddress> tag in a
\&    DescribeInstancesResponse, becomes:
\&
\&           $instance\->privateIpAddress
\&
\&    You can also use the more Perlish form \-\- this is equivalent:
\&
\&          $instance\->private_ip_address
\&
\&    Methods that correspond to complex objects in the XML hierarchy
\&    return the appropriate Perl object. For example, an instance\*(Aqs
\&    blockDeviceMapping() method returns an object of type
\&    VM::EC2::BlockDevice::Mapping.
\&
\&    All objects have a fields() method that will return the XML
\&    tagnames listed in the AWS specifications.
\&
\&      @fields = sort $instance\->fields;
\&      # \*(AqamiLaunchIndex\*(Aq, \*(Aqarchitecture\*(Aq, \*(AqblockDeviceMapping\*(Aq, ...
\&
\& 8) Whenever an object has a unique ID, string overloading is used so that 
\&    the object interpolates the ID into the string. For example, when you
\&    print a VM::EC2::Volume object, or use it in another string context,
\&    then it will appear as the string "vol\-123456". Nevertheless, it will
\&    continue to be usable for method calls.
\&
\&         ($v) = $ec2\->describe_volumes();
\&         print $v,"\en";                 # prints as "vol\-123456"
\&         $zone = $v\->availabilityZone;  # acts like an object
\&
\& 9) Many objects have convenience methods that invoke the AWS API on your
\&    behalf. For example, instance objects have a current_status() method that returns
\&    the run status of the object, as well as start(), stop() and terminate()
\&    methods that control the instance\*(Aqs lifecycle.
\&
\&         if ($instance\->current_status eq \*(Aqrunning\*(Aq) {
\&             $instance\->stop;
\&         }
\&
\& 10) Calls to AWS that have failed for one reason or another (invalid
\&    parameters, communications problems, service interruptions) will
\&    return undef and set the VM::EC2\->is_error() method to true. The
\&    error message and its code can then be recovered by calling
\&    VM::EC2\->error.
\&
\&      $i = $ec2\->describe_instance(\*(Aqi\-123456\*(Aq);
\&      unless ($i) {
\&          warn \*(AqGot no instance. Message was: \*(Aq,$ec2\->error;
\&      }
\&
\&    You may also elect to raise an exception when an error occurs.
\&    See the new() method for details.
.Ve
.SH "CORE METHODS"
.IX Header "CORE METHODS"
This section describes the \s-1VM::EC2\s0 constructor, accessor methods, and
methods relevant to error handling.
.ie n .SS "$ec2 = \s-1VM::EC2\-\s0>new(\-access_key=>$id,\-secret_key=>$key,\-endpoint=>$url)"
.el .SS "\f(CW$ec2\fP = \s-1VM::EC2\-\s0>new(\-access_key=>$id,\-secret_key=>$key,\-endpoint=>$url)"
.IX Subsection "$ec2 = VM::EC2->new(-access_key=>$id,-secret_key=>$key,-endpoint=>$url)"
Create a new Amazon access object. Required parameters are:
.PP
.Vb 1
\& \-access_key   Access ID for an authorized user
\&
\& \-secret_key   Secret key corresponding to the Access ID
\&
\& \-endpoint     The URL for making API requests
\&
\& \-raise_error  If true, throw an exception.
\&
\& \-print_error  If true, print errors to STDERR.
.Ve
.PP
One or more of \-access_key, \-secret_key and \-endpoint can be omitted
if the environment variables \s-1EC2_ACCESS_KEY\s0, \s-1EC2_SECRET_KEY\s0 and
\&\s-1EC2_URL\s0 are defined.
.PP
To use a Eucalyptus cloud, please provide the appropriate endpoint
\&\s-1URL\s0.
.PP
By default, when the Amazon \s-1API\s0 reports an error, such as attempting
to perform an invalid operation on an instance, the corresponding
method will return empty and the error message can be recovered from
\&\f(CW$ec2\fR\->\fIerror()\fR. However, if you pass \-raise_error=>1 to \fInew()\fR, the module
will instead raise a fatal error, which you can trap with eval{} and
report with $@:
.PP
.Vb 5
\&  eval {
\&     $ec2\->some_dangerous_operation();
\&     $ec2\->another_dangerous_operation();
\&  };
\&  print STDERR "something bad happened: $@" if $@;
.Ve
.PP
The error object can be retrieved with \f(CW$ec2\fR\->\fIerror()\fR as before.
.ie n .SS "$access_key = $ec2\->access_key(<$new_access_key>)"
.el .SS "\f(CW$access_key\fP = \f(CW$ec2\fP\->access_key(<$new_access_key>)"
.IX Subsection "$access_key = $ec2->access_key(<$new_access_key>)"
Get or set the \s-1ACCESS\s0 \s-1KEY\s0
.ie n .SS "$secret = $ec2\->secret(<$new_secret>)"
.el .SS "\f(CW$secret\fP = \f(CW$ec2\fP\->secret(<$new_secret>)"
.IX Subsection "$secret = $ec2->secret(<$new_secret>)"
Get or set the \s-1SECRET\s0 \s-1KEY\s0
.ie n .SS "$endpoint = $ec2\->endpoint(<$new_endpoint>)"
.el .SS "\f(CW$endpoint\fP = \f(CW$ec2\fP\->endpoint(<$new_endpoint>)"
.IX Subsection "$endpoint = $ec2->endpoint(<$new_endpoint>)"
Get or set the \s-1ENDPOINT\s0 \s-1URL\s0.
.ie n .SS "$ec2\->raise_error($boolean)"
.el .SS "\f(CW$ec2\fP\->raise_error($boolean)"
.IX Subsection "$ec2->raise_error($boolean)"
Change the handling of error conditions. Pass a true value to cause
Amazon \s-1API\s0 errors to raise a fatal error. Pass false to make methods
return undef. In either case, you can detect the error condition
by calling \fIis_error()\fR and fetch the error message using \fIerror()\fR. This
method will also return the current state of the raise error flag.
.ie n .SS "$ec2\->print_error($boolean)"
.el .SS "\f(CW$ec2\fP\->print_error($boolean)"
.IX Subsection "$ec2->print_error($boolean)"
Change the handling of error conditions. Pass a true value to cause
Amazon \s-1API\s0 errors to print error messages to \s-1STDERR\s0. Pass false to
cancel this behavior.
.ie n .SS "$boolean = $ec2\->is_error"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->is_error"
.IX Subsection "$boolean = $ec2->is_error"
If a method fails, it will return undef. However, some methods, such
as \fIdescribe_images()\fR, will also return undef if no resources matches
your search criteria. Call \fIis_error()\fR to distinguish the two
eventualities:
.PP
.Vb 5
\&  @images = $ec2\->describe_images(\-owner=>\*(Aq29731912785\*(Aq);
\&  unless (@images) {
\&      die "Error: ",$ec2\->error if $ec2\->is_error;
\&      print "No appropriate images found\en";
\&  }
.Ve
.ie n .SS "$err = $ec2\->error"
.el .SS "\f(CW$err\fP = \f(CW$ec2\fP\->error"
.IX Subsection "$err = $ec2->error"
If the most recently-executed method failed, \f(CW$ec2\fR\->\fIerror()\fR will return
the error code and other descriptive information. This method will
return undef if the most recently executed method was successful.
.PP
The returned object is actually an AWS::Error object, which
has two methods named \fIcode()\fR and \fImessage()\fR. If used in a string
context, its operator overloading returns the composite string
\&\*(L"$message [$code]\*(R".
.ie n .SS "$err = $ec2\->error_str"
.el .SS "\f(CW$err\fP = \f(CW$ec2\fP\->error_str"
.IX Subsection "$err = $ec2->error_str"
Same as \fIerror()\fR except it returns the string representation, not the
object. This works better in debuggers and exception handlers.
.SH "EC2 REGIONS AND AVAILABILITY ZONES"
.IX Header "EC2 REGIONS AND AVAILABILITY ZONES"
This section describes methods that allow you to fetch information on
\&\s-1EC2\s0 regions and availability zones. These methods return objects of
type VM::EC2::Region and VM::EC2::AvailabilityZone.
.ie n .SS "@regions = $ec2\->describe_regions(\-region_name=>\e@list)"
.el .SS "\f(CW@regions\fP = \f(CW$ec2\fP\->describe_regions(\-region_name=>\e@list)"
.IX Subsection "@regions = $ec2->describe_regions(-region_name=>@list)"
.ie n .SS "@regionss = $ec2\->describe_regions(@list)"
.el .SS "\f(CW@regionss\fP = \f(CW$ec2\fP\->describe_regions(@list)"
.IX Subsection "@regionss = $ec2->describe_regions(@list)"
Describe regions and return a list of VM::EC2::Region objects. Call
with no arguments to return all regions. You may provide a list of
regions in either of the two forms shown above in order to restrict
the list returned. Glob-style wildcards, such as \*(L"*east\*(R") are allowed.
.ie n .SS "@zones = $ec2\->describe_availability_zones(\-zone_name=>\e@names,\-filter=>\e%filters)"
.el .SS "\f(CW@zones\fP = \f(CW$ec2\fP\->describe_availability_zones(\-zone_name=>\e@names,\-filter=>\e%filters)"
.IX Subsection "@zones = $ec2->describe_availability_zones(-zone_name=>@names,-filter=>%filters)"
.ie n .SS "@zones = $ec2\->describe_availability_zones(@names)"
.el .SS "\f(CW@zones\fP = \f(CW$ec2\fP\->describe_availability_zones(@names)"
.IX Subsection "@zones = $ec2->describe_availability_zones(@names)"
Describe availability zones and return a list of
VM::EC2::AvailabilityZone objects. Call with no arguments to return
all availability regions. You may provide a list of zones in either
of the two forms shown above in order to restrict the list
returned. Glob-style wildcards, such as \*(L"*east\*(R") are allowed.
.PP
If you provide a single argument consisting of a hashref, it is
treated as a \-filter argument. In other words:
.PP
.Vb 1
\& $ec2\->describe_availability_zones({state=>\*(Aqavailable\*(Aq})
.Ve
.PP
is equivalent to
.PP
.Vb 1
\& $ec2\->describe_availability_zones(\-filter=>{state=>\*(Aqavailable\*(Aq})
.Ve
.PP
Availability zone filters are described at
http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference\-query\-DescribeAvailabilityZones.html
.SH "EC2 INSTANCES"
.IX Header "EC2 INSTANCES"
The methods in this section allow you to retrieve information about
\&\s-1EC2\s0 instances, launch new instances, control the instance lifecycle
(e.g. starting and stopping them), and fetching the console output
from instances.
.PP
The primary object manipulated by these methods is
VM::EC2::Instance. Please see the VM::EC2::Instance manual page
for additional methods that allow you to attach and detach volumes,
modify an instance's attributes, and convert instances into images.
.ie n .SS "@instances = $ec2\->describe_instances(\-instance_id=>\e@ids,\-filter=>\e%filters)"
.el .SS "\f(CW@instances\fP = \f(CW$ec2\fP\->describe_instances(\-instance_id=>\e@ids,\-filter=>\e%filters)"
.IX Subsection "@instances = $ec2->describe_instances(-instance_id=>@ids,-filter=>%filters)"
.ie n .SS "@instances = $ec2\->describe_instances(@instance_ids)"
.el .SS "\f(CW@instances\fP = \f(CW$ec2\fP\->describe_instances(@instance_ids)"
.IX Subsection "@instances = $ec2->describe_instances(@instance_ids)"
.ie n .SS "@instances = $ec2\->describe_instances(\e%filters)"
.el .SS "\f(CW@instances\fP = \f(CW$ec2\fP\->describe_instances(\e%filters)"
.IX Subsection "@instances = $ec2->describe_instances(%filters)"
Return a series of VM::EC2::Instance objects. Optional parameters are:
.PP
.Vb 2
\& \-instance_id     ID of the instance(s) to return information on. 
\&                  This can be a string scalar, or an arrayref.
\&
\& \-filter          Tags and other filters to apply.
.Ve
.PP
The filter argument is a hashreference in which the keys are the
filter names, and the values are the match strings. Some filters
accept wildcards.
.PP
A typical filter example:
.PP
.Vb 5
\&  $ec2\->describe_instances(
\&    \-filter        => {\*(Aqblock\-device\-mapping.device\-name\*(Aq=>\*(Aq/dev/sdh\*(Aq,
\&                       \*(Aqarchitecture\*(Aq                    => \*(Aqi386\*(Aq,
\&                       \*(Aqtag:Role\*(Aq                        => \*(AqServer\*(Aq
\&                      });
.Ve
.PP
You may omit the \-filter argument name if there are no other arguments:
.PP
.Vb 3
\&  $ec2\->describe_instances({\*(Aqblock\-device\-mapping.device\-name\*(Aq=>\*(Aq/dev/sdh\*(Aq,
\&                            \*(Aqarchitecture\*(Aq                    => \*(Aqi386\*(Aq,
\&                             \*(Aqtag:Role\*(Aq                        => \*(AqServer\*(Aq});
.Ve
.PP
There are a large number of potential filters, which are listed at
http://docs.amazonwebservices.com/AWSEC2/2011\-05\-15/APIReference/ApiReference\-query\-DescribeInstances.html.
.PP
Note that the objects returned from this method are the instances
themselves, and not a reservation set. The reservation \s-1ID\s0 can be
retrieved from each instance by calling its \fIreservationId()\fR method.
.ie n .SS "@i = $ec2\->run_instances(%param)"
.el .SS "\f(CW@i\fP = \f(CW$ec2\fP\->run_instances(%param)"
.IX Subsection "@i = $ec2->run_instances(%param)"
This method will provision and launch one or more instances given an
\&\s-1AMI\s0 \s-1ID\s0. If successful, the method returns a series of
VM::EC2::Instance objects.
.IP "Required parameters:" 4
.IX Item "Required parameters:"
.Vb 1
\&  \-image_id       ID of an AMI to launch
.Ve
.IP "Optional parameters:" 4
.IX Item "Optional parameters:"
.Vb 10
\&  \-min_count         Minimum number of instances to launch [1]
\&  \-max_count         Maximum number of instances to launch [1]
\&  \-key_name          Name of the keypair to use
\&  \-security_group_id Security group ID to use for this instance.
\&                     Use an arrayref for multiple group IDs
\&  \-security_group    Security group name to use for this instance.
\&                     Use an arrayref for multiple values.
\&  \-user_data         User data to pass to the instances. Do NOT base64
\&                     encode this. It will be done for you.
\&  \-instance_type     Type of the instance to use. See below for a
\&                     list.
\&  \-availability_zone The availability zone you want to launch the
\&                     instance into. Call $ec2\->regions for a list.
\&  \-zone              Short version of \-availability_aone.
\&  \-placement_zone    Deprecated version of \-availability_zone.
\&  \-placement_group   An existing placement group to launch the
\&                     instance into. Applicable to cluster instances
\&                     only.
\&  \-placement_tenancy Specify \*(Aqdedicated\*(Aq to launch the instance on a
\&                     dedicated server. Only applicable for VPC
\&                     instances.
\&  \-kernel_id         ID of the kernel to use for the instances,
\&                     overriding the kernel specified in the image.
\&  \-ramdisk_id        ID of the ramdisk to use for the instances,
\&                     overriding the ramdisk specified in the image.
\&  \-block_devices     Specify block devices to map onto the instances,
\&                     overriding the values specified in the image.
\&                     See below for the syntax of this argument.
\&  \-block_device_mapping  Alias for \-block_devices.
\&  \-monitoring        Pass a true value to enable detailed monitoring.
\&  \-subnet_id         ID of the subnet to launch the instance
\&                     into. Only applicable for VPC instances.
\&  \-termination_protection  Pass true to lock the instance so that it
\&                     cannot be terminated using the API. Use
\&                     modify_instance() to unset this if youu wish to
\&                     terminate the instance later.
\&  \-disable_api_termination \-\- Same as above.
\&  \-shutdown_behavior Pass "stop" (the default) to stop the instance
\&                     and save its disk state when "shutdown" is called
\&                     from within the instance. Stopped instances can
\&                     be restarted later. Pass "terminate" to
\&                     instead terminate the instance and discard its
\&                     state completely.
\&  \-instance_initiated_shutdown_behavior \-\- Same as above.
\&  \-private_ip_address Assign the instance to a specific IP address
\&                     from a VPC subnet (VPC only).
\&  \-client_token      Unique identifier that you can provide to ensure
\&                     idempotency of the request. You can use
\&                     $ec2\->token() to generate a suitable identifier.
\&                     See http://docs.amazonwebservices.com/AWSEC2/
\&                         latest/UserGuide/Run_Instance_Idempotency.html
.Ve
.IP "Instance types" 4
.IX Item "Instance types"
The following is the list of instance types currently allowed by
Amazon:
.Sp
.Vb 3
\&   m1.small   c1.medium  m2.xlarge   cc1.4xlarge  cg1.4xlarge  t1.micro
\&   m1.large   c1.xlarge  m2.2xlarge   
\&   m1.xlarge             m2.4xlarge
.Ve
.IP "Block device syntax" 4
.IX Item "Block device syntax"
The syntax of \-block_devices is identical to what is used by the
ec2\-run\-instances command-line tool. Borrowing from the manual page of
that tool:
.Sp
The format is '<device>=<block\-device>', where 'block\-device' can be one of the
following:
.Sp
.Vb 2
\&    \- \*(Aqnone\*(Aq: indicates that a block device that would be exposed at the
\&       specified device should be suppressed. For example: \*(Aq/dev/sdb=none\*(Aq
\&          
\&     \- \*(Aqephemeral[0\-3]\*(Aq: indicates that the Amazon EC2 ephemeral store
\&       (instance local storage) should be exposed at the specified device.
\&       For example: \*(Aq/dev/sdc=ephemeral0\*(Aq.
\&          
\&     \- \*(Aq[<snapshot\-id>][:<size>[:<delete\-on\-termination>]]\*(Aq: indicates
\&       that an Amazon EBS volume, created from the specified Amazon EBS
\&       snapshot, should be exposed at the specified device. The following
\&       combinations are supported:
\&          
\&         \- \*(Aq<snapshot\-id>\*(Aq: the ID of an Amazon EBS snapshot, which must
\&           be owned by or restorable by the caller. May be left out if a
\&           <size> is specified, creating an empty Amazon EBS volume of
\&           the specified size.
\&          
\&         \- \*(Aq<size>\*(Aq: the size (GiBs) of the Amazon EBS volume to be
\&           created. If a snapshot was specified, this may not be smaller
\&           than the size of the snapshot itself.
\&          
\&         \- \*(Aq<delete\-on\-termination>\*(Aq: indicates whether the Amazon EBS
\&            volume should be deleted on instance termination. If not
\&            specified, this will default to \*(Aqtrue\*(Aq and the volume will be
\&            deleted.
\&          
\&         Examples: \-block_devices => \*(Aq/dev/sdb=snap\-7eb96d16\*(Aq
\&                   \-block_devices => \*(Aq/dev/sdc=snap\-7eb96d16:80:false\*(Aq
\&                   \-block_devices => \*(Aq/dev/sdd=:120\*(Aq
.Ve
.Sp
To provide multiple mappings, use an array reference. In this example,
we launch two 'm1.small' instance in which /dev/sdb is mapped to
ephemeral storage and /dev/sdc is mapped to a new 100 G \s-1EBS\s0 volume:
.Sp
.Vb 5
\& @i=$ec2\->run_instances(\-image_id  => \*(Aqami\-12345\*(Aq,
\&                        \-min_count => 2,
\&                        \-block_devices => [\*(Aq/dev/sdb=ephemeral0\*(Aq,
\&                                           \*(Aq/dev/sdc=:100:true\*(Aq]
\&    )
.Ve
.IP "Return value" 4
.IX Item "Return value"
On success, this method returns a list of VM::EC2::Instance
objects. If called in a scalar context \s-1AND\s0 only one instance was
requested, it will return a single instance object (rather than
returning a list of size one which is then converted into numeric \*(L"1\*(R",
as would be the usual Perl behavior).
.Sp
Note that this behavior is different from the Amazon \s-1API\s0, which
returns a ReservationSet. In this \s-1API\s0, ask the instances for the
the reservation, owner, requester, and group information using
\&\fIreservationId()\fR, \fIownerId()\fR, \fIrequesterId()\fR and \fIgroups()\fR methods.
.IP "Tips" 4
.IX Item "Tips"
1. If you have a VM::EC2::Image object returned from
   \fIDescribe_images()\fR, you may run it using \fIrun_instances()\fR:
.Sp
.Vb 5
\& my $image = $ec2\->describe_images(\-image_id  => \*(Aqami\-12345\*(Aq);
\& $image\->run_instances( \-min_count => 10,
\&                        \-block_devices => [\*(Aq/dev/sdb=ephemeral0\*(Aq,
\&                                           \*(Aq/dev/sdc=:100:true\*(Aq]
\&    )
.Ve
.Sp
2. It may take a short while for a newly-launched instance to be
    returned by \fIdescribe_instances()\fR. You may need to sleep for 1\-2 seconds
    before \fIcurrent_status()\fR returns the correct value.
.Sp
3. Each instance object has a \fIcurrent_status()\fR method which will
   return the current run state of the instance. You may poll this
   method to wait until the instance is running:
.Sp
.Vb 5
\&   my $instance = $ec2\->run_instances(...);
\&   sleep 1;
\&   while ($instance\->current_status ne \*(Aqrunning\*(Aq) {
\&      sleep 5;
\&   }
.Ve
.Sp
4. The utility method \fIwait_for_instances()\fR will wait until all
   passed instances are in the 'running' or other terminal state.
.Sp
.Vb 2
\&   my @instances = $ec2\->run_instances(...);
\&   $ec2\->wait_for_instances(@instances);
.Ve
.ie n .SS "@s = $ec2\->start_instances(\-instance_id=>\e@instance_ids) =head2 @s = $ec2\->start_instances(@instance_ids)"
.el .SS "\f(CW@s\fP = \f(CW$ec2\fP\->start_instances(\-instance_id=>\e@instance_ids) =head2 \f(CW@s\fP = \f(CW$ec2\fP\->start_instances(@instance_ids)"
.IX Subsection "@s = $ec2->start_instances(-instance_id=>@instance_ids) =head2 @s = $ec2->start_instances(@instance_ids)"
Start the instances named by \f(CW@instance_ids\fR and return one or more
VM::EC2::Instance::State::Change objects.
.PP
To wait for the all the instance ids to reach their final state
(\*(L"running\*(R" unless an error occurs), call \fIwait_for_instances()\fR.
.PP
Example:
.PP
.Vb 2
\&    # find all stopped instances
\&    @instances = $ec2\->describe_instances(\-filter=>{\*(Aqinstance\-state\-name\*(Aq=>\*(Aqstopped\*(Aq});
\&
\&    # start them
\&    $ec2\->start_instances(@instances)
\&
\&    # pause till they are running (or crashed)
\&    $ec2\->wait_for_instances(@instances)
.Ve
.PP
You can also start an instance by calling the object's \fIstart()\fR method:
.PP
.Vb 2
\&    $instances[0]\->start(\*(Aqwait\*(Aq);  # start instance and wait for it to
\&                                   # be running
.Ve
.PP
The objects returned by calling \fIstart_instances()\fR indicate the current
and previous states of the instance. The previous state is typically
\&\*(L"stopped\*(R" and the current state is usually \*(L"pending.\*(R" This information
is only current to the time that the \fIstart_instances()\fR method was called.
To get the current run state of the instance, call its \fIstatus()\fR
method:
.PP
.Vb 1
\&  die "ouch!" unless $instances[0]\->current_status eq \*(Aqrunning\*(Aq;
.Ve
.ie n .SS "@s = $ec2\->stop_instances(\-instance_id=>\e@instance_ids,\-force=>1)"
.el .SS "\f(CW@s\fP = \f(CW$ec2\fP\->stop_instances(\-instance_id=>\e@instance_ids,\-force=>1)"
.IX Subsection "@s = $ec2->stop_instances(-instance_id=>@instance_ids,-force=>1)"
.ie n .SS "@s = $ec2\->stop_instances(@instance_ids)"
.el .SS "\f(CW@s\fP = \f(CW$ec2\fP\->stop_instances(@instance_ids)"
.IX Subsection "@s = $ec2->stop_instances(@instance_ids)"
Stop the instances named by \f(CW@instance_ids\fR and return one or more
VM::EC2::Instance::State::Change objects. In the named parameter
version of this method, you may optionally provide a \-force argument,
which if true, forces the instance to halt without giving it a chance
to run its shutdown procedure (the equivalent of pulling a physical
machine's plug).
.PP
To wait for instances to reach their final state, call
\&\fIwait_for_instances()\fR.
.PP
Example:
.PP
.Vb 2
\&    # find all running instances
\&    @instances = $ec2\->describe_instances(\-filter=>{\*(Aqinstance\-state\-name\*(Aq=>\*(Aqrunning\*(Aq});
\&
\&    # stop them immediately and wait for confirmation
\&    $ec2\->stop_instances(\-instance_id=>\e@instances,\-force=>1);
\&    $ec2\->wait_for_instances(@instances);
.Ve
.PP
You can also stop an instance by calling the object's \fIstart()\fR method:
.PP
.Vb 2
\&    $instances[0]\->stop(\*(Aqwait\*(Aq);  # stop first instance and wait for it to
\&                                  # stop completely
.Ve
.ie n .SS "@s = $ec2\->terminate_instances(\-instance_id=>\e@instance_ids)"
.el .SS "\f(CW@s\fP = \f(CW$ec2\fP\->terminate_instances(\-instance_id=>\e@instance_ids)"
.IX Subsection "@s = $ec2->terminate_instances(-instance_id=>@instance_ids)"
.ie n .SS "@s = $ec2\->terminate_instances(@instance_ids)"
.el .SS "\f(CW@s\fP = \f(CW$ec2\fP\->terminate_instances(@instance_ids)"
.IX Subsection "@s = $ec2->terminate_instances(@instance_ids)"
Terminate the instances named by \f(CW@instance_ids\fR and return one or more
VM::EC2::Instance::State::Change objects. This method will fail
for any instances whose termination protection field is set.
.PP
To wait for the all the instances to reach their final state, call
\&\fIwait_for_instances()\fR.
.PP
Example:
.PP
.Vb 2
\&    # find all instances tagged as "Version 0.5"
\&    @instances = $ec2\->describe_instances({\*(Aqtag:Version\*(Aq=>\*(Aq0.5\*(Aq});
\&
\&    # terminate them
\&    $ec2\->terminate_instances(@instances);
.Ve
.PP
You can also terminate an instance by calling its \fIterminate()\fR method:
.PP
.Vb 1
\&    $instances[0]\->terminate;
.Ve
.ie n .SS "@s = $ec2\->reboot_instances(\-instance_id=>\e@instance_ids)"
.el .SS "\f(CW@s\fP = \f(CW$ec2\fP\->reboot_instances(\-instance_id=>\e@instance_ids)"
.IX Subsection "@s = $ec2->reboot_instances(-instance_id=>@instance_ids)"
.ie n .SS "@s = $ec2\->reboot_instances(@instance_ids)"
.el .SS "\f(CW@s\fP = \f(CW$ec2\fP\->reboot_instances(@instance_ids)"
.IX Subsection "@s = $ec2->reboot_instances(@instance_ids)"
Reboot the instances named by \f(CW@instance_ids\fR and return one or more
VM::EC2::Instance::State::Change objects.
.PP
To wait for the all the instances to reach their final state, call
\&\fIwait_for_instances()\fR.
.PP
You can also reboot an instance by calling its \fIterminate()\fR method:
.PP
.Vb 1
\&    $instances[0]\->reboot;
.Ve
.ie n .SS "$t = $ec2\->token"
.el .SS "\f(CW$t\fP = \f(CW$ec2\fP\->token"
.IX Subsection "$t = $ec2->token"
Return a client token for use with \fIstart_instances()\fR.
.ie n .SS "$ec2\->wait_for_instances(@instances)"
.el .SS "\f(CW$ec2\fP\->wait_for_instances(@instances)"
.IX Subsection "$ec2->wait_for_instances(@instances)"
Wait for all members of the provided list of instances to reach some
terminal state (\*(L"running\*(R", \*(L"stopped\*(R" or \*(L"terminated\*(R"), and then return
a hash reference that maps each instance \s-1ID\s0 to its final state.
.PP
Typical usage:
.PP
.Vb 8
\& my @instances = $image\->run_instances(\-key_name      =>\*(AqMy_key\*(Aq,
\&                                       \-security_group=>\*(Aqdefault\*(Aq,
\&                                       \-min_count     =>2,
\&                                       \-instance_type => \*(Aqt1.micro\*(Aq)
\&           or die $ec2\->error_str;
\& my $status = $ec2\->wait_for_instances(@instances);
\& my @failed = grep {$status\->{$_} ne \*(Aqrunning\*(Aq} @instances;
\& print "The following failed: @failed\en";
.Ve
.PP
If no terminal state is reached within a set timeout, then this method
returns undef and sets \f(CW$ec2\fR\->\fIerror_str()\fR to a suitable message. The
timeout, which defaults to 10 minutes (600 seconds), can be get or set
with \f(CW$ec2\fR\->\fIwait_for_timeout()\fR.
.ie n .SS "$ec2\->wait_for_snapshots(@snapshots)"
.el .SS "\f(CW$ec2\fP\->wait_for_snapshots(@snapshots)"
.IX Subsection "$ec2->wait_for_snapshots(@snapshots)"
Wait for all members of the provided list of snapshots to reach some
terminal state (\*(L"completed\*(R", \*(L"error\*(R"), and then return a hash
reference that maps each snapshot \s-1ID\s0 to its final state.
.PP
This method may potentially wait forever. It has no set timeout. Wrap
it in an eval{} and set \fIalarm()\fR if you wish to timeout.
.ie n .SS "$ec2\->wait_for_volumes(@volumes)"
.el .SS "\f(CW$ec2\fP\->wait_for_volumes(@volumes)"
.IX Subsection "$ec2->wait_for_volumes(@volumes)"
Wait for all members of the provided list of volumes to reach some
terminal state (\*(L"available\*(R", \*(L"in-use\*(R", \*(L"deleted\*(R" or \*(L"error\*(R"), and then
return a hash reference that maps each volume \s-1ID\s0 to its final state.
.PP
If no terminal state is reached within a set timeout, then this method
returns undef and sets \f(CW$ec2\fR\->\fIerror_str()\fR to a suitable message. The
timeout, which defaults to 10 minutes (600 seconds), can be get or set
with \f(CW$ec2\fR\->\fIwait_for_timeout()\fR.
.ie n .SS "$ec2\->wait_for_attachments(@attachment)"
.el .SS "\f(CW$ec2\fP\->wait_for_attachments(@attachment)"
.IX Subsection "$ec2->wait_for_attachments(@attachment)"
Wait for all members of the provided list of
VM::EC2::BlockDevice::Attachment objects to reach some terminal state
(\*(L"attached\*(R" or \*(L"detached\*(R"), and then return a hash reference that maps
each attachment to its final state.
.PP
Typical usage:
.PP
.Vb 9
\&    my $i = 0;
\&    my $instance = \*(Aqi\-12345\*(Aq;
\&    my @attach;
\&    foreach (@volume) {
\&        push @attach,$_\->attach($instance,\*(Aq/dev/sdf\*(Aq.$i++;
\&    }
\&    my $s = $ec2\->wait_for_attachments(@attach);
\&    my @failed = grep($s\->{$_} ne \*(Aqattached\*(Aq} @attach;
\&    warn "did not attach: ",join \*(Aq, \*(Aq,@failed;
.Ve
.PP
If no terminal state is reached within a set timeout, then this method
returns undef and sets \f(CW$ec2\fR\->\fIerror_str()\fR to a suitable message. The
timeout, which defaults to 10 minutes (600 seconds), can be get or set
with \f(CW$ec2\fR\->\fIwait_for_timeout()\fR.
.ie n .SS "$ec2\->wait_for_terminal_state(\e@objects,['list','of','states'] [,$timeout])"
.el .SS "\f(CW$ec2\fP\->wait_for_terminal_state(\e@objects,['list','of','states'] [,$timeout])"
.IX Subsection "$ec2->wait_for_terminal_state(@objects,['list','of','states'] [,$timeout])"
Generic version of the last four methods. Wait for all members of the provided list of Amazon objects 
instances to reach some terminal state listed in the second argument, and then return
a hash reference that maps each object \s-1ID\s0 to its final state.
.PP
If a timeout is provided, in seconds, then the method will abort after
waiting the indicated time and return undef.
.ie n .SH "$timeout = $ec2\->wait_for_timeout([$new_timeout]);"
.el .SH "\f(CW$timeout\fP = \f(CW$ec2\fP\->wait_for_timeout([$new_timeout]);"
.IX Header "$timeout = $ec2->wait_for_timeout([$new_timeout]);"
Get or change the timeout for \fIwait_for_instances()\fR, \fIwait_for_attachments()\fR,
and \fIwait_for_volumes()\fR. The timeout is given in seconds, and defaults to
600 (10 minutes). You can set this to 0 to wait forever.
.ie n .SS "$password_data = $ec2\->get_password_data(\-instance_id=>'i\-12345');"
.el .SS "\f(CW$password_data\fP = \f(CW$ec2\fP\->get_password_data(\-instance_id=>'i\-12345');"
.IX Subsection "$password_data = $ec2->get_password_data(-instance_id=>'i-12345');"
.ie n .SS "$password_data = $ec2\->get_password_data('i\-12345');"
.el .SS "\f(CW$password_data\fP = \f(CW$ec2\fP\->get_password_data('i\-12345');"
.IX Subsection "$password_data = $ec2->get_password_data('i-12345');"
For Windows instances, get the administrator's password as a
VM::EC2::Instance::PasswordData object.
.ie n .SS "$output = $ec2\->get_console_output(\-instance_id=>'i\-12345')"
.el .SS "\f(CW$output\fP = \f(CW$ec2\fP\->get_console_output(\-instance_id=>'i\-12345')"
.IX Subsection "$output = $ec2->get_console_output(-instance_id=>'i-12345')"
.ie n .SS "$output = $ec2\->get_console_output('i\-12345');"
.el .SS "\f(CW$output\fP = \f(CW$ec2\fP\->get_console_output('i\-12345');"
.IX Subsection "$output = $ec2->get_console_output('i-12345');"
Return the console output of the indicated instance. The output is
actually a VM::EC2::ConsoleOutput object, but it is
overloaded so that when treated as a string it will appear as a
large text string containing the  console output. When treated like an
object it provides \fIinstanceId()\fR and \fItimestamp()\fR methods.
.ie n .SS "@monitoring_state = $ec2\->monitor_instances(@list_of_instanceIds)"
.el .SS "\f(CW@monitoring_state\fP = \f(CW$ec2\fP\->monitor_instances(@list_of_instanceIds)"
.IX Subsection "@monitoring_state = $ec2->monitor_instances(@list_of_instanceIds)"
.ie n .SS "@monitoring_state = $ec2\->monitor_instances(\-instance_id=>\e@instanceIds)"
.el .SS "\f(CW@monitoring_state\fP = \f(CW$ec2\fP\->monitor_instances(\-instance_id=>\e@instanceIds)"
.IX Subsection "@monitoring_state = $ec2->monitor_instances(-instance_id=>@instanceIds)"
This method enables monitoring for the listed instances and returns a
list of VM::EC2::Instance::MonitoringState objects. You can
later use these objects to activate and inactivate monitoring.
.ie n .SS "@monitoring_state = $ec2\->unmonitor_instances(@list_of_instanceIds)"
.el .SS "\f(CW@monitoring_state\fP = \f(CW$ec2\fP\->unmonitor_instances(@list_of_instanceIds)"
.IX Subsection "@monitoring_state = $ec2->unmonitor_instances(@list_of_instanceIds)"
.ie n .SS "@monitoring_state = $ec2\->unmonitor_instances(\-instance_id=>\e@instanceIds)"
.el .SS "\f(CW@monitoring_state\fP = \f(CW$ec2\fP\->unmonitor_instances(\-instance_id=>\e@instanceIds)"
.IX Subsection "@monitoring_state = $ec2->unmonitor_instances(-instance_id=>@instanceIds)"
This method disables monitoring for the listed instances and returns a
list of VM::EC2::Instance::MonitoringState objects. You can
later use these objects to activate and inactivate monitoring.
.ie n .SS "$meta = $ec2\->instance_metadata"
.el .SS "\f(CW$meta\fP = \f(CW$ec2\fP\->instance_metadata"
.IX Subsection "$meta = $ec2->instance_metadata"
\&\fBFor use on running \s-1EC2\s0 instances only:\fR This method returns a
VM::EC2::Instance::Metadata object that will return information about
the currently running instance using the \s-1HTTP://\s0 metadata fields
described at
http://docs.amazonwebservices.com/AWSEC2/latest/UserGuide/index.html?instancedata\-data\-categories.html. This
is usually fastest way to get runtime information on the current
instance.
.ie n .SS "@data = $ec2\->describe_instance_attribute($instance_id,$attribute)"
.el .SS "\f(CW@data\fP = \f(CW$ec2\fP\->describe_instance_attribute($instance_id,$attribute)"
.IX Subsection "@data = $ec2->describe_instance_attribute($instance_id,$attribute)"
This method returns instance attributes. Only one attribute can be
retrieved at a time. The following is the list of attributes that can be
retrieved:
.PP
.Vb 10
\& instanceType                      \-\- scalar
\& kernel                            \-\- scalar
\& ramdisk                           \-\- scalar
\& userData                          \-\- scalar
\& disableApiTermination             \-\- scalar
\& instanceInitiatedShutdownBehavior \-\- scalar
\& rootDeviceName                    \-\- scalar
\& blockDeviceMapping                \-\- list of hashref
\& sourceDestCheck                   \-\- scalar
\& groupSet                          \-\- list of scalar
.Ve
.PP
All of these values can be retrieved more conveniently from the
VM::EC2::Instance object returned from \fIdescribe_instances()\fR, so
there is no attempt to parse the results of this call into Perl
objects. Therefore, some of the attributes, in particular
\&'blockDeviceMapping' will be returned as raw hashrefs.
.ie n .SS "$boolean = $ec2\->modify_instance_attribute($instance_id,\-$attribute_name=>$value)"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->modify_instance_attribute($instance_id,\-$attribute_name=>$value)"
.IX Subsection "$boolean = $ec2->modify_instance_attribute($instance_id,-$attribute_name=>$value)"
This method changes instance attributes. It can only be applied to stopped instances.
The following is the list of attributes that can be set:
.PP
.Vb 10
\& \-instance_type           \-\- type of instance, e.g. "m1.small"
\& \-kernel                  \-\- kernel id
\& \-ramdisk                 \-\- ramdisk id
\& \-user_data               \-\- user data
\& \-termination_protection  \-\- true to prevent termination from the console
\& \-disable_api_termination \-\- same as the above
\& \-shutdown_behavior       \-\- "stop" or "terminate"
\& \-instance_initiated_shutdown_behavior \-\- same as above
\& \-root_device_name        \-\- root device name
\& \-source_dest_check       \-\- enable NAT (VPC only)
\& \-group_id                \-\- VPC security group
\& \-block_devices           \-\- Specify block devices to change 
\&                             deleteOnTermination flag
\& \-block_device_mapping    \-\- Alias for \-block_devices
.Ve
.PP
Only one attribute can be changed in a single request. For example:
.PP
.Vb 1
\&  $ec2\->modify_instance_attribute(\*(Aqi\-12345\*(Aq,\-kernel=>\*(Aqaki\-f70657b2\*(Aq);
.Ve
.PP
The result code is true if the attribute was successfully modified,
false otherwise. In the latter case, \f(CW$ec2\fR\->\fIerror()\fR will provide the
error message.
.PP
The ability to change the deleteOnTermination flag for attached block devices
is not documented in the official Amazon \s-1API\s0 documentation, but appears to work.
The syntax is:
.PP
# turn on deleteOnTermination
 \f(CW$ec2\fR\->modify_instance_attribute(\-block_devices=>'/dev/sdf=v\-12345')
# turn off deleteOnTermination
 \f(CW$ec2\fR\->modify_instance_attribute(\-block_devices=>'/dev/sdf=v\-12345')
.PP
The syntax is slightly different from what is used by \-block_devices
in \fIrun_instances()\fR, and is \*(L"device=volumeId:boolean\*(R". Multiple block
devices can be specified using an arrayref.
.ie n .SS "$boolean = $ec2\->reset_instance_attribute($instance_id,$attribute)"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->reset_instance_attribute($instance_id,$attribute)"
.IX Subsection "$boolean = $ec2->reset_instance_attribute($instance_id,$attribute)"
This method resets an attribute of the given instance to its default
value. Valid attributes are \*(L"kernel\*(R", \*(L"ramdisk\*(R" and
\&\*(L"sourceDestCheck\*(R". The result code is true if the reset was
successful.
.SH "EC2 AMAZON MACHINE IMAGES"
.IX Header "EC2 AMAZON MACHINE IMAGES"
The methods in this section allow you to query and manipulate Amazon
machine images (AMIs). See VM::EC2::Image.
.ie n .SS "@i = $ec2\->describe_images(\-image_id=>\e@id,\-executable_by=>$id, \-owner=>$id, \-filter=>\e%filters)"
.el .SS "\f(CW@i\fP = \f(CW$ec2\fP\->describe_images(\-image_id=>\e@id,\-executable_by=>$id, \-owner=>$id, \-filter=>\e%filters)"
.IX Subsection "@i = $ec2->describe_images(-image_id=>@id,-executable_by=>$id, -owner=>$id, -filter=>%filters)"
.ie n .SS "@i = $ec2\->describe_images(@image_ids)"
.el .SS "\f(CW@i\fP = \f(CW$ec2\fP\->describe_images(@image_ids)"
.IX Subsection "@i = $ec2->describe_images(@image_ids)"
Return a series of VM::EC2::Image objects, each describing an
\&\s-1AMI\s0. Optional parameters:
.PP
.Vb 2
\& \-image_id        The id of the image, either a string scalar or an
\&                  arrayref.
\&
\& \-executable_by   Filter by images executable by the indicated user account
\&
\& \-owner           Filter by owner account
\&
\& \-filter          Tags and other filters to apply
.Ve
.PP
If there are no other arguments, you may omit the \-filter argument
name and call \fIdescribe_images()\fR with a single hashref consisting of
the search filters you wish to apply.
.PP
The full list of image filters can be found at:
http://docs.amazonwebservices.com/AWSEC2/2011\-05\-15/APIReference/ApiReference\-query\-DescribeImages.html
.ie n .SS "$image = $ec2\->create_image(%args)"
.el .SS "\f(CW$image\fP = \f(CW$ec2\fP\->create_image(%args)"
.IX Subsection "$image = $ec2->create_image(%args)"
Create an image from an EBS-backed instance and return a
VM::EC2::Image object. The instance must be in the \*(L"stopped\*(R" or
\&\*(L"running\*(R" state. In the latter case, Amazon will stop the instance,
create the image, and then restart it unless the \-no_reboot argument
is provided.
.PP
Arguments:
.PP
.Vb 4
\& \-instance_id    ID of the instance to create an image from. (required)
\& \-name           Name for the image that will be created. (required)
\& \-description    Description of the new image.
\& \-no_reboot      If true, don\*(Aqt reboot the instance.
.Ve
.ie n .SS "$image = $ec2\->register_image(%args)"
.el .SS "\f(CW$image\fP = \f(CW$ec2\fP\->register_image(%args)"
.IX Subsection "$image = $ec2->register_image(%args)"
Register an image, creating an \s-1AMI\s0. This can be used to create an \s-1AMI\s0
from a S3\-backed instance-store bundle, or to create an \s-1AMI\s0 from a
snapshot of an EBS-backed root volume.
.PP
Required arguments:
.PP
.Vb 1
\& \-name                 Name for the image that will be created.
.Ve
.PP
Arguments required for an EBS-backed image:
.PP
.Vb 7
\& \-root_device_name     The root device name, e.g. /dev/sda1
\& \-block_device_mapping The block device mapping strings, including the
\&                       snapshot ID for the root volume. This can
\&                       be either a scalar string or an arrayref.
\&                       See run_instances() for a description of the
\&                       syntax.
\& \-block_devices        Alias of the above.
.Ve
.PP
Arguments required for an instance-store image:
.PP
.Vb 1
\& \-image_location      Full path to the AMI manifest in Amazon S3 storage.
.Ve
.PP
Common optional arguments:
.PP
.Vb 4
\& \-description         Description of the AMI
\& \-architecture        Architecture of the image ("i386" or "x86_64")
\& \-kernel_id           ID fo the kernel to use
\& \-ramdisk_id          ID of the RAM disk to use
.Ve
.PP
While you do not have to specify the kernel \s-1ID\s0, it is strongly
recommended that you do so. Otherwise the kernel will have to be
specified for \fIrun_instances()\fR.
.PP
Note: Immediately after registering the image you can add tags to it
and use modify_image_attribute to change launch permissions, etc.
.ie n .SS "$result = $ec2\->deregister_image($image_id)"
.el .SS "\f(CW$result\fP = \f(CW$ec2\fP\->deregister_image($image_id)"
.IX Subsection "$result = $ec2->deregister_image($image_id)"
Deletes the registered image and returns true if successful.
.ie n .SS "@data = $ec2\->describe_image_attribute($image_id,$attribute)"
.el .SS "\f(CW@data\fP = \f(CW$ec2\fP\->describe_image_attribute($image_id,$attribute)"
.IX Subsection "@data = $ec2->describe_image_attribute($image_id,$attribute)"
This method returns image attributes. Only one attribute can be
retrieved at a time. The following is the list of attributes that can be
retrieved:
.PP
.Vb 6
\& description            \-\- scalar
\& kernel                 \-\- scalar
\& ramdisk                \-\- scalar
\& launchPermission       \-\- list of scalar
\& productCodes           \-\- array
\& blockDeviceMapping     \-\- list of hashref
.Ve
.PP
All of these values can be retrieved more conveniently from the
VM::EC2::Image object returned from \fIdescribe_images()\fR, so there is
no attempt to parse the results of this call into Perl objects. In
particular, 'blockDeviceMapping' is returned as a raw hashrefs (there
also seems to be an \s-1AWS\s0 bug that causes fetching this attribute to return an
AuthFailure error).
.PP
Please see the VM::EC2::Image \fIlaunchPermissions()\fR and
\&\fIblockDeviceMapping()\fR methods for more convenient ways to get this
data.
.ie n .SS "$boolean = $ec2\->modify_image_attribute($image_id,\-$attribute_name=>$value)"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->modify_image_attribute($image_id,\-$attribute_name=>$value)"
.IX Subsection "$boolean = $ec2->modify_image_attribute($image_id,-$attribute_name=>$value)"
This method changes image attributes. The first argument is the image
\&\s-1ID\s0, and this is followed by the attribute name and the value to change
it to.
.PP
The following is the list of attributes that can be set:
.PP
.Vb 7
\& \-launch_add_user         \-\- scalar or arrayref of UserIds to grant launch permissions to
\& \-launch_add_group        \-\- scalar or arrayref of Groups to remove launch permissions from
\&                               (only currently valid value is "all")
\& \-launch_remove_user      \-\- scalar or arrayref of UserIds to remove from launch permissions
\& \-launch_remove_group     \-\- scalar or arrayref of Groups to remove from launch permissions
\& \-product_code            \-\- scalar or array of product codes to add
\& \-description             \-\- scalar new description
.Ve
.PP
You can abbreviate the launch permission arguments to \-add_user,
\&\-add_group, \-remove_user, \-remove_group, etc.
.PP
Only one attribute can be changed in a single request.
.PP
For example:
.PP
.Vb 1
\&  $ec2\->modify_image_attribute(\*(Aqi\-12345\*(Aq,\-product_code=>[\*(Aqabcde\*(Aq,\*(Aqghijk\*(Aq]);
.Ve
.PP
The result code is true if the attribute was successfully modified,
false otherwise. In the latter case, \f(CW$ec2\fR\->\fIerror()\fR will provide the
error message.
.PP
To make an image public, specify \-launch_add_group=>'all':
.PP
.Vb 1
\&  $ec2\->modify_image_attribute(\*(Aqi\-12345\*(Aq,\-launch_add_group=>\*(Aqall\*(Aq);
.Ve
.PP
Also see VM::EC2::Image for shortcut methods. For example:
.PP
.Vb 1
\& $image\->add_authorized_users(1234567,999991);
.Ve
.ie n .SS "$boolean = $ec2\->reset_image_attribute($image_id,$attribute_name)"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->reset_image_attribute($image_id,$attribute_name)"
.IX Subsection "$boolean = $ec2->reset_image_attribute($image_id,$attribute_name)"
This method resets an attribute of the given snapshot to its default
value. The valid attributes are:
.PP
.Vb 1
\& launchPermission
.Ve
.SH "EC2 VOLUMES AND SNAPSHOTS"
.IX Header "EC2 VOLUMES AND SNAPSHOTS"
The methods in this section allow you to query and manipulate \s-1EC2\s0 \s-1EBS\s0
volumes and snapshots. See VM::EC2::Volume and VM::EC2::Snapshot
for additional functionality provided through the object interface.
.ie n .SS "@v = $ec2\->describe_volumes(\-volume_id=>\e@ids,\-filter=>\e%filters)"
.el .SS "\f(CW@v\fP = \f(CW$ec2\fP\->describe_volumes(\-volume_id=>\e@ids,\-filter=>\e%filters)"
.IX Subsection "@v = $ec2->describe_volumes(-volume_id=>@ids,-filter=>%filters)"
.ie n .SS "@v = $ec2\->describe_volumes(@volume_ids)"
.el .SS "\f(CW@v\fP = \f(CW$ec2\fP\->describe_volumes(@volume_ids)"
.IX Subsection "@v = $ec2->describe_volumes(@volume_ids)"
Return a series of VM::EC2::Volume objects. Optional parameters:
.PP
.Vb 2
\& \-volume_id    The id of the volume to fetch, either a string
\&               scalar or an arrayref.
\&
\& \-filter       One or more filters to apply to the search
.Ve
.PP
The \-filter argument name can be omitted if there are no other
arguments you wish to pass.
.PP
The full list of volume filters can be found at:
http://docs.amazonwebservices.com/AWSEC2/2011\-05\-15/APIReference/ApiReference\-query\-DescribeVolumes.html
.ie n .SS "$v = $ec2\->create_volume(\-availability_zone=>$zone,\-snapshot_id=>$snapshotId,\-size=>$size)"
.el .SS "\f(CW$v\fP = \f(CW$ec2\fP\->create_volume(\-availability_zone=>$zone,\-snapshot_id=>$snapshotId,\-size=>$size)"
.IX Subsection "$v = $ec2->create_volume(-availability_zone=>$zone,-snapshot_id=>$snapshotId,-size=>$size)"
Create a volume in the specified availability zone and return
information about it.
.PP
Arguments:
.PP
.Vb 2
\& \-availability_zone    \-\- An availability zone from
\&                          describe_availability_zones (required)
\&
\& \-snapshot_id          \-\- ID of a snapshot to use to build volume from.
\&
\& \-size                 \-\- Size of the volume, in GB (between 1 and 1024).
.Ve
.PP
One or both of \-snapshot_id or \-size are required. For convenience,
you may abbreviate \-availability_zone as \-zone, and \-snapshot_id as
\&\-snapshot.
.PP
The returned object is a VM::EC2::Volume object.
.ie n .SS "$result = $ec2\->delete_volume($volume_id);"
.el .SS "\f(CW$result\fP = \f(CW$ec2\fP\->delete_volume($volume_id);"
.IX Subsection "$result = $ec2->delete_volume($volume_id);"
Deletes the specified volume. Returns a boolean indicating success of
the delete operation. Note that a volume will remain in the \*(L"deleting\*(R"
state for some time after this call completes.
.ie n .SS "$attachment = $ec2\->attach_volume($volume_id,$instance_id,$device);"
.el .SS "\f(CW$attachment\fP = \f(CW$ec2\fP\->attach_volume($volume_id,$instance_id,$device);"
.IX Subsection "$attachment = $ec2->attach_volume($volume_id,$instance_id,$device);"
.ie n .SS "$attachment = $ec2\->attach_volume(\-volume_id=>$volume_id,\-instance_id=>$instance_id,\-device=>$device);"
.el .SS "\f(CW$attachment\fP = \f(CW$ec2\fP\->attach_volume(\-volume_id=>$volume_id,\-instance_id=>$instance_id,\-device=>$device);"
.IX Subsection "$attachment = $ec2->attach_volume(-volume_id=>$volume_id,-instance_id=>$instance_id,-device=>$device);"
Attaches the specified volume to the instance using the indicated
device. All arguments are required:
.PP
.Vb 6
\& \-volume_id      \-\- ID of the volume to attach. The volume must be in
\&                    "available" state.
\& \-instance_id    \-\- ID of the instance to attach to. Both instance and
\&                    attachment must be in the same availability zone.
\& \-device         \-\- How the device is exposed to the instance, e.g.
\&                    \*(Aq/dev/sdg\*(Aq.
.Ve
.PP
The result is a VM::EC2::BlockDevice::Attachment object which
you can monitor by calling \fIcurrent_status()\fR:
.PP
.Vb 5
\&    my $a = $ec2\->attach_volume(\*(Aqvol\-12345\*(Aq,\*(Aqi\-12345\*(Aq,\*(Aq/dev/sdg\*(Aq);
\&    while ($a\->current_status ne \*(Aqattached\*(Aq) {
\&       sleep 2;
\&    }
\&    print "volume is ready to go\en";
.Ve
.PP
or more simply
.PP
.Vb 2
\&    my $a = $ec2\->attach_volume(\*(Aqvol\-12345\*(Aq,\*(Aqi\-12345\*(Aq,\*(Aq/dev/sdg\*(Aq);
\&    $ec2\->wait_for_attachments($a);
.Ve
.ie n .SS "$attachment = $ec2\->detach_volume($volume_id)"
.el .SS "\f(CW$attachment\fP = \f(CW$ec2\fP\->detach_volume($volume_id)"
.IX Subsection "$attachment = $ec2->detach_volume($volume_id)"
.ie n .SS "$attachment = $ec2\->detach_volume(\-volume_id=>$volume_id,\-instance_id=>$instance_id, \-device=>$device,      \-force=>$force);"
.el .SS "\f(CW$attachment\fP = \f(CW$ec2\fP\->detach_volume(\-volume_id=>$volume_id,\-instance_id=>$instance_id, \-device=>$device,      \-force=>$force);"
.IX Subsection "$attachment = $ec2->detach_volume(-volume_id=>$volume_id,-instance_id=>$instance_id, -device=>$device,      -force=>$force);"
Detaches the specified volume from an instance.
.PP
.Vb 5
\& \-volume_id      \-\- ID of the volume to detach. (required)
\& \-instance_id    \-\- ID of the instance to detach from. (optional)
\& \-device         \-\- How the device is exposed to the instance. (optional)
\& \-force          \-\- Force detachment, even if previous attempts were
\&                    unsuccessful. (optional)
.Ve
.PP
The result is a VM::EC2::BlockDevice::Attachment object which
you can monitor by calling \fIcurrent_status()\fR:
.PP
.Vb 5
\&    my $a = $ec2\->detach_volume(\*(Aqvol\-12345\*(Aq);
\&    while ($a\->current_status ne \*(Aqdetached\*(Aq) {
\&       sleep 2;
\&    }
\&    print "volume is ready to go\en";
.Ve
.PP
Or more simply:
.PP
.Vb 3
\&    my $a = $ec2\->detach_volume(\*(Aqvol\-12345\*(Aq);
\&    $ec2\->wait_for_attachments($a);
\&    print "volume is ready to go\en" if $a\->current_status eq \*(Aqdetached\*(Aq;
.Ve
.ie n .SS "@snaps = $ec2\->describe_snapshots(\-snapshot_id=>\e@ids,%other_param)"
.el .SS "\f(CW@snaps\fP = \f(CW$ec2\fP\->describe_snapshots(\-snapshot_id=>\e@ids,%other_param)"
.IX Subsection "@snaps = $ec2->describe_snapshots(-snapshot_id=>@ids,%other_param)"
.ie n .SS "@snaps = $ec2\->describe_snapshots(@snapshot_ids)"
.el .SS "\f(CW@snaps\fP = \f(CW$ec2\fP\->describe_snapshots(@snapshot_ids)"
.IX Subsection "@snaps = $ec2->describe_snapshots(@snapshot_ids)"
Returns a series of VM::EC2::Snapshot objects. All parameters
are optional:
.PP
.Vb 1
\& \-snapshot_id     ID of the snapshot
\&
\& \-owner           Filter by owner ID
\&
\& \-restorable_by   Filter by IDs of a user who is allowed to restore
\&                   the snapshot
\&
\& \-filter          Tags and other filters
.Ve
.PP
The \-filter argument name can be omitted if there are no other
arguments you wish to pass.
.PP
The full list of applicable filters can be found at
http://docs.amazonwebservices.com/AWSEC2/2011\-05\-15/APIReference/ApiReference\-query\-DescribeSnapshots.html
.ie n .SS "@data = $ec2\->describe_snapshot_attribute($snapshot_id,$attribute)"
.el .SS "\f(CW@data\fP = \f(CW$ec2\fP\->describe_snapshot_attribute($snapshot_id,$attribute)"
.IX Subsection "@data = $ec2->describe_snapshot_attribute($snapshot_id,$attribute)"
This method returns snapshot attributes. The first argument is the
snapshot \s-1ID\s0, and the second is the name of the attribute to
fetch. Currently Amazon defines only one attribute,
\&\*(L"createVolumePermission\*(R", which will return a list of user Ids who are
allowed to create volumes from this snapshot.
.PP
The result is a raw hash of attribute values. Please see
VM::EC2::Snapshot for a more convenient way of accessing and
modifying snapshot attributes.
.ie n .SS "$boolean = $ec2\->modify_snapshot_attribute($snapshot_id,\-$argument=>$value)"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->modify_snapshot_attribute($snapshot_id,\-$argument=>$value)"
.IX Subsection "$boolean = $ec2->modify_snapshot_attribute($snapshot_id,-$argument=>$value)"
This method changes snapshot attributes. The first argument is the
snapshot \s-1ID\s0, and this is followed by an attribute modification command
and the value to change it to.
.PP
Currently the only attribute that can be changed is the
createVolumeAttribute. This is done through the following arguments
.PP
.Vb 5
\& \-createvol_add_user         \-\- scalar or arrayref of UserIds to grant create volume permissions to
\& \-createvol_add_group        \-\- scalar or arrayref of Groups to remove create volume permissions from
\&                               (only currently valid value is "all")
\& \-createvol_remove_user      \-\- scalar or arrayref of UserIds to remove from create volume permissions
\& \-createvol_remove_group     \-\- scalar or arrayref of Groups to remove from create volume permissions
.Ve
.PP
You can abbreviate these to \-add_user, \-add_group, \-remove_user, \-remove_group, etc.
.PP
See VM::EC2::Snapshot for more convenient methods for interrogating
and modifying the create volume permissions.
.ie n .SS "$boolean = $ec2\->reset_snapshot_attribute($snapshot_id,$attribute)"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->reset_snapshot_attribute($snapshot_id,$attribute)"
.IX Subsection "$boolean = $ec2->reset_snapshot_attribute($snapshot_id,$attribute)"
This method resets an attribute of the given snapshot to its default
value. The only valid attribute at this time is
\&\*(L"createVolumePermission.\*(R"
.ie n .SS "$snapshot = $ec2\->create_snapshot($volume_id)"
.el .SS "\f(CW$snapshot\fP = \f(CW$ec2\fP\->create_snapshot($volume_id)"
.IX Subsection "$snapshot = $ec2->create_snapshot($volume_id)"
.ie n .SS "$snapshot = $ec2\->create_snapshot(\-volume_id=>$vol,\-description=>$desc)"
.el .SS "\f(CW$snapshot\fP = \f(CW$ec2\fP\->create_snapshot(\-volume_id=>$vol,\-description=>$desc)"
.IX Subsection "$snapshot = $ec2->create_snapshot(-volume_id=>$vol,-description=>$desc)"
Snapshot the \s-1EBS\s0 volume and store it to S3 storage. To ensure a
consistent snapshot, the volume should be unmounted prior to
initiating this operation.
.PP
Arguments:
.PP
.Vb 2
\& \-volume_id    \-\- ID of the volume to snapshot (required)
\& \-description  \-\- A description to add to the snapshot (optional)
.Ve
.PP
The return value is a VM::EC2::Snapshot object that can be queried
through its \fIcurrent_status()\fR interface to follow the progress of the
snapshot operation.
.PP
Another way to accomplish the same thing is through the
VM::EC2::Volume interface:
.PP
.Vb 6
\&  my $volume = $ec2\->describe_volumes(\-filter=>{\*(Aqtag:Name\*(Aq=>\*(AqAccountingData\*(Aq});
\&  $s = $volume\->create_snapshot("Backed up at ".localtime);
\&  while ($s\->current_status eq \*(Aqpending\*(Aq) {
\&     print "Progress: ",$s\->progress,"% done\en";
\&  }
\&  print "Snapshot status: ",$s\->current_status,"\en";
.Ve
.ie n .SS "$boolean = $ec2\->delete_snapshot($snapshot_id)"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->delete_snapshot($snapshot_id)"
.IX Subsection "$boolean = $ec2->delete_snapshot($snapshot_id)"
Delete the indicated snapshot and return true if the request was
successful.
.SH "SECURITY GROUPS AND KEY PAIRS"
.IX Header "SECURITY GROUPS AND KEY PAIRS"
The methods in this section allow you to query and manipulate security
groups (firewall rules) and \s-1SSH\s0 key pairs. See
VM::EC2::SecurityGroup and VM::EC2::KeyPair for functionality
that is available through these objects.
.ie n .SS "@sg = $ec2\->describe_security_groups(\-group_id  => \e@ids, \-group_name=> \e@names, \-filter    => \e%filters);"
.el .SS "\f(CW@sg\fP = \f(CW$ec2\fP\->describe_security_groups(\-group_id  => \e@ids, \-group_name=> \e@names, \-filter    => \e%filters);"
.IX Subsection "@sg = $ec2->describe_security_groups(-group_id  => @ids, -group_name=> @names, -filter    => %filters);"
.ie n .SS "@sg = $ec2\->describe_security_groups(@group_ids)"
.el .SS "\f(CW@sg\fP = \f(CW$ec2\fP\->describe_security_groups(@group_ids)"
.IX Subsection "@sg = $ec2->describe_security_groups(@group_ids)"
Searches for security groups (firewall rules) matching the provided
filters and return a series of VM::EC2::SecurityGroup objects.
.PP
Optional parameters:
.PP
.Vb 2
\& \-group_name      A single group name or an arrayref containing a list
\&                   of names
\&
\& \-name            Shorter version of \-group_name
\&
\& \-group_id        A single group id (i.e. \*(Aqsg\-12345\*(Aq) or an arrayref
\&                   containing a list of ids
\&
\& \-filter          Filter on tags and other attributes.
.Ve
.PP
The \-filter argument name can be omitted if there are no other
arguments you wish to pass.
.PP
The full list of security group filters can be found at:
http://docs.amazonwebservices.com/AWSEC2/2011\-05\-15/APIReference/ApiReference\-query\-DescribeSecurityGroups.html
.ie n .SS "$group = $ec2\->create_security_group(\-group_name=>$name, \-group_description=>$description, \-vpc_id     => $vpc_id )"
.el .SS "\f(CW$group\fP = \f(CW$ec2\fP\->create_security_group(\-group_name=>$name, \-group_description=>$description, \-vpc_id     => \f(CW$vpc_id\fP )"
.IX Subsection "$group = $ec2->create_security_group(-group_name=>$name, -group_description=>$description, -vpc_id     => $vpc_id )"
Create a security group. Arguments are:
.PP
.Vb 4
\& \-group_name              Name of the security group (required)
\& \-group_description       Description of the security group (required)
\& \-vpc_id                  Virtual private cloud security group ID
\&                           (required for VPC security groups)
.Ve
.PP
For convenience, you may use \-name and \-description as aliases for
\&\-group_name and \-group_description respectively.
.PP
If succcessful, the method returns an object of type
VM::EC2::SecurityGroup.
.ie n .SS "$boolean = $ec2\->delete_security_group($group_id)"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->delete_security_group($group_id)"
.IX Subsection "$boolean = $ec2->delete_security_group($group_id)"
.ie n .SS "$boolean = $ec2\->delete_security_group(\-group_id=>$group_id, \-group_name=>$name);"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->delete_security_group(\-group_id=>$group_id, \-group_name=>$name);"
.IX Subsection "$boolean = $ec2->delete_security_group(-group_id=>$group_id, -group_name=>$name);"
Delete a security group. Arguments are:
.PP
.Vb 2
\& \-group_name              Name of the security group
\& \-group_id                ID of the security group
.Ve
.PP
Either \-group_name or \-group_id is required. In the single-argument
form, the method deletes the security group given by its id.
.PP
If succcessful, the method returns true.
.ie n .SS "$boolean = $ec2\->update_security_group($security_group)"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->update_security_group($security_group)"
.IX Subsection "$boolean = $ec2->update_security_group($security_group)"
Add one or more incoming firewall rules to a security group. The rules
to add are stored in a VM::EC2::SecurityGroup which is created
either by \fIdescribe_security_groups()\fR or \fIcreate_security_group()\fR. This method combines
the actions AuthorizeSecurityGroupIngress,
AuthorizeSecurityGroupEgress, RevokeSecurityGroupIngress, and
RevokeSecurityGroupEgress.
.PP
For details, see VM::EC2::SecurityGroup. Here is a brief summary:
.PP
.Vb 1
\& $sg = $ec2\->create_security_group(\-name=>\*(AqMyGroup\*(Aq,\-description=>\*(AqExample group\*(Aq);
\&
\& # TCP on port 80 for the indicated address ranges
\& $sg\->authorize_incoming(\-protocol  => \*(Aqtcp\*(Aq,
\&                         \-port      => 80,
\&                         \-source_ip => [\*(Aq192.168.2.0/24\*(Aq,\*(Aq192.168.2.1/24\*(Aq});
\&
\& # TCP on ports 22 and 23 from anyone
\& $sg\->authorize_incoming(\-protocol  => \*(Aqtcp\*(Aq,
\&                         \-port      => \*(Aq22..23\*(Aq,
\&                         \-source_ip => \*(Aq0.0.0.0/0\*(Aq);
\&
\& # ICMP on echo (ping) port from anyone
\& $sg\->authorize_incoming(\-protocol  => \*(Aqicmp\*(Aq,
\&                         \-port      => 0,
\&                         \-source_ip => \*(Aq0.0.0.0/0\*(Aq);
\&
\& # TCP to port 25 (mail) from instances belonging to
\& # the "Mail relay" group belonging to user 12345678.
\& $sg\->authorize_incoming(\-protocol  => \*(Aqtcp\*(Aq,
\&                         \-port      => 25,
\&                         \-group     => \*(Aq12345678/Mail relay\*(Aq);
\&
\& $result = $ec2\->update_security_group($sg);
.Ve
.PP
or more simply:
.PP
.Vb 1
\& $result = $sg\->update();
.Ve
.ie n .SS "$account_id = $ec2\->account_id"
.el .SS "\f(CW$account_id\fP = \f(CW$ec2\fP\->account_id"
.IX Subsection "$account_id = $ec2->account_id"
Looks up the account \s-1ID\s0 corresponding to the credentials provided when
the \s-1VM::EC2\s0 instance was created. The way this is done is to fetch the
\&\*(L"default\*(R" security group, which is guaranteed to exist, and then
return its groupId field. The result is cached so that subsequent
accesses are fast.
.ie n .SS "$account_id = $ec2\->userId"
.el .SS "\f(CW$account_id\fP = \f(CW$ec2\fP\->userId"
.IX Subsection "$account_id = $ec2->userId"
Same as above, for convenience.
.ie n .SS "@keys = $ec2\->describe_key_pairs(\-key_name => \e@names, \-filter    => \e%filters); =head2 @keys = $ec2\->describe_key_pairs(@names);"
.el .SS "\f(CW@keys\fP = \f(CW$ec2\fP\->describe_key_pairs(\-key_name => \e@names, \-filter    => \e%filters); =head2 \f(CW@keys\fP = \f(CW$ec2\fP\->describe_key_pairs(@names);"
.IX Subsection "@keys = $ec2->describe_key_pairs(-key_name => @names, -filter    => %filters); =head2 @keys = $ec2->describe_key_pairs(@names);"
Searches for ssh key pairs matching the provided filters and return
a series of VM::EC2::KeyPair objects.
.PP
Optional parameters:
.PP
.Vb 3
\& \-key_name      A single key name or an arrayref containing a list
\&                   of names
\& \-filter          Filter on tags and other attributes.
.Ve
.PP
The full list of key filters can be found at:
http://docs.amazonwebservices.com/AWSEC2/2011\-05\-15/APIReference/ApiReference\-query\-DescribeKeyPairs.html
.ie n .SS "$key = $ec2\->create_key_pair($name)"
.el .SS "\f(CW$key\fP = \f(CW$ec2\fP\->create_key_pair($name)"
.IX Subsection "$key = $ec2->create_key_pair($name)"
Create a new key pair with the specified name (required). If the key
pair already exists, returns undef. The contents of the new keypair,
including the PEM-encoded private key, is contained in the returned
VM::EC2::KeyPair object:
.PP
.Vb 5
\&  my $key = $ec2\->create_key_pair(\*(AqMy Keypair\*(Aq);
\&  if ($key) {
\&    print $key\->fingerprint,"\en";
\&    print $key\->privateKey,"\en";
\&  }
.Ve
.ie n .SS "$key = $ec2\->import_key_pair(\-key_name=>$name, \-public_key_material=>$public_key)"
.el .SS "\f(CW$key\fP = \f(CW$ec2\fP\->import_key_pair(\-key_name=>$name, \-public_key_material=>$public_key)"
.IX Subsection "$key = $ec2->import_key_pair(-key_name=>$name, -public_key_material=>$public_key)"
.ie n .SS "$key = $ec2\->import_key_pair($name,$public_key)"
.el .SS "\f(CW$key\fP = \f(CW$ec2\fP\->import_key_pair($name,$public_key)"
.IX Subsection "$key = $ec2->import_key_pair($name,$public_key)"
Imports a preexisting public key into \s-1AWS\s0 under the specified name.
If successful, returns a VM::EC2::KeyPair. The public key must be an
\&\s-1RSA\s0 key of length 1024, 2048 or 4096. The method can be called with
two unnamed arguments consisting of the key name and the public key
material, or in a named argument form with the following argument
names:
.PP
.Vb 2
\&  \-key_name     \-\- desired name for the imported key pair (required)
\&  \-name         \-\- shorter version of \-key_name
\&
\&  \-public_key_material \-\- public key data (required)
\&  \-public_key   \-\- shorter version of the above
.Ve
.PP
This example uses Net::SSH::Perl::Key to generate a new keypair, and
then uploads the public key to Amazon.
.PP
.Vb 1
\&  use Net::SSH::Perl::Key;
\&
\&  my $newkey = Net::SSH::Perl::Key\->keygen(\*(AqRSA\*(Aq,1024);
\&  $newkey\->write_private(\*(Aq.ssh/MyKeypair.rsa\*(Aq);  # save private parts
\&
\&  my $key = $ec2\->import_key_pair(\*(AqMy Keypair\*(Aq => $newkey\->dump_public)
\&      or die $ec2\->error;
\&  print "My Keypair added with fingerprint ",$key\->fingerprint,"\en";
.Ve
.PP
Several different formats are accepted for the key, including \s-1SSH\s0
\&\*(L"authorized_keys\*(R" format (generated by ssh-keygen and
Net::SSH::Perl::Key), the \s-1SSH\s0 public keys format, and \s-1DER\s0 format. You
do not need to base64\-encode the key or perform any other
pre-processing.
.PP
Note that the algorithm used by Amazon to calculate its key
fingerprints differs from the one used by the ssh library, so don't
try to compare the key fingerprints returned by Amazon to the ones
produced by ssh-keygen or Net::SSH::Perl::Key.
.ie n .SS "$result = $ec2\->delete_key_pair($name)"
.el .SS "\f(CW$result\fP = \f(CW$ec2\fP\->delete_key_pair($name)"
.IX Subsection "$result = $ec2->delete_key_pair($name)"
Deletes the key pair with the specified name (required). Returns true
if successful.
.SH "TAGS"
.IX Header "TAGS"
These methods allow you to create, delete and fetch resource tags. You
may find that you rarely need to use these methods directly because
every object produced by \s-1VM::EC2\s0 supports a simple tag interface:
.PP
.Vb 5
\&  $object = $ec2\->describe_volumes(\-volume_id=>\*(Aqvol\-12345\*(Aq); # e.g.
\&  $tags = $object\->tags();
\&  $name = $tags\->{Name};
\&  $object\->add_tags(Role => \*(AqWeb Server\*(Aq, Status=>\*(Aqdevelopment);
\&  $object\->delete_tags(Name=>undef);
.Ve
.PP
See VM::EC2::Generic for a full description of the uniform object
tagging interface.
.PP
These methods are most useful when creating and deleting tags for
multiple resources simultaneously.
.ie n .SS "@t = $ec2\->describe_tags(\-filter=>\e%filters);"
.el .SS "\f(CW@t\fP = \f(CW$ec2\fP\->describe_tags(\-filter=>\e%filters);"
.IX Subsection "@t = $ec2->describe_tags(-filter=>%filters);"
Return a series of VM::EC2::Tag objects, each describing an
\&\s-1AMI\s0. A single optional \-filter argument is allowed.
.PP
Available filters are: key, resource-id, resource-type and value. See
http://docs.amazonwebservices.com/AWSEC2/2011\-05\-15/APIReference/ApiReference\-query\-DescribeTags.html
.ie n .SS "$bool = $ec2\->create_tags(\-resource_id=>\e@ids,\-tag=>{key1=>value1...})"
.el .SS "\f(CW$bool\fP = \f(CW$ec2\fP\->create_tags(\-resource_id=>\e@ids,\-tag=>{key1=>value1...})"
.IX Subsection "$bool = $ec2->create_tags(-resource_id=>@ids,-tag=>{key1=>value1...})"
Tags the resource indicated by \-resource_id with the tag(s) in in the
hashref indicated by \-tag. You may specify a single resource by
passing a scalar resourceId to \-resource_id, or multiple resources
using an anonymous array. Returns a true value if tagging was
successful.
.PP
The method name \*(L"\fIadd_tags()\fR\*(R" is an alias for \fIcreate_tags()\fR.
.PP
You may find it more convenient to tag an object retrieved with any of
the \fIdescribe()\fR methods using the built-in \fIadd_tags()\fR method:
.PP
.Vb 2
\& @snap = $ec2\->describe_snapshots(\-filter=>{status=>\*(Aqcompleted\*(Aq});
\& foreach (@snap) {$_\->add_tags(ReadyToUse => \*(Aqtrue\*(Aq)}
.Ve
.PP
but if there are many snapshots to tag simultaneously, this will be faster:
.PP
.Vb 2
\& @snap = $ec2\->describe_snapshots(\-filter=>{status=>\*(Aqcompleted\*(Aq});
\& $ec2\->add_tags(\-resource_id=>\e@snap,\-tag=>{ReadyToUse=>\*(Aqtrue\*(Aq});
.Ve
.PP
Note that you can tag volumes, snapshots and images owned by other
people. Only you will be able to see these tags.
.ie n .SS "$bool = $ec2\->delete_tags(\-resource_id=>$id1,\-tag=>{key1=>value1...})"
.el .SS "\f(CW$bool\fP = \f(CW$ec2\fP\->delete_tags(\-resource_id=>$id1,\-tag=>{key1=>value1...})"
.IX Subsection "$bool = $ec2->delete_tags(-resource_id=>$id1,-tag=>{key1=>value1...})"
Delete the indicated tags from the indicated resource. Pass an
arrayref to operate on several resources at once. The tag syntax is a
bit tricky. Use a value of undef to delete the tag unconditionally:
.PP
.Vb 1
\& \-tag => { Role => undef }    # deletes any Role tag
.Ve
.PP
Any scalar value will cause the tag to be deleted only if its value
exactly matches the specified value:
.PP
.Vb 2
\& \-tag => { Role => \*(AqServer\*(Aq }  # only delete the Role tag
\&                               # if it currently has the value "Server"
.Ve
.PP
An empty string value ('') will only delete the tag if its value is an
empty string, which is probably not what you want.
.PP
Pass an array reference of tag names to delete each of the tag names
unconditionally (same as passing a value of undef):
.PP
.Vb 1
\& $ec2\->delete_tags([\*(AqName\*(Aq,\*(AqRole\*(Aq,\*(AqDescription\*(Aq]);
.Ve
.PP
You may find it more convenient to delete tags from objects using
their \fIdelete_tags()\fR method:
.PP
.Vb 2
\& @snap = $ec2\->describe_snapshots(\-filter=>{status=>\*(Aqcompleted\*(Aq});
\& foreach (@snap) {$_\->delete_tags(Role => undef)}
.Ve
.SH "ELASTIC IP ADDRESSES"
.IX Header "ELASTIC IP ADDRESSES"
The methods in this section allow you to allocate elastic \s-1IP\s0
addresses, attach them to instances, and delete them. See
VM::EC2::ElasticAddress.
.ie n .SS "@addr = $ec2\->describe_addresses(\-public_ip=>\e@addr,\-allocation_id=>\e@id,\-filter\->\e%filters)"
.el .SS "\f(CW@addr\fP = \f(CW$ec2\fP\->describe_addresses(\-public_ip=>\e@addr,\-allocation_id=>\e@id,\-filter\->\e%filters)"
.IX Subsection "@addr = $ec2->describe_addresses(-public_ip=>@addr,-allocation_id=>@id,-filter->%filters)"
.ie n .SS "@addr = $ec2\->describe_addresses(@public_ips)"
.el .SS "\f(CW@addr\fP = \f(CW$ec2\fP\->describe_addresses(@public_ips)"
.IX Subsection "@addr = $ec2->describe_addresses(@public_ips)"
Queries \s-1AWS\s0 for a list of elastic \s-1IP\s0 addresses already allocated to
you. All parameters are optional:
.PP
.Vb 6
\& \-public_ip     \-\- An IP address (in dotted format) or an arrayref of
\&                   addresses to return information about.
\& \-allocation_id \-\- An allocation ID or arrayref of such IDs. Only 
\&                   applicable to VPC addresses.
\& \-filter        \-\- A hashref of tag=>value pairs to filter the response
\&                   on.
.Ve
.PP
The list of applicable filters can be found at
http://docs.amazonwebservices.com/AWSEC2/2011\-05\-15/APIReference/ApiReference\-query\-DescribeAddresses.html.
.PP
This method returns a list of VM::EC2::ElasticAddress.
.ie n .SS "$address_info = $ec2\->allocate_address([\-vpc=>1])"
.el .SS "\f(CW$address_info\fP = \f(CW$ec2\fP\->allocate_address([\-vpc=>1])"
.IX Subsection "$address_info = $ec2->allocate_address([-vpc=>1])"
Request an elastic \s-1IP\s0 address. Pass \-vpc=>1 to allocate a \s-1VPC\s0 elastic
address. The return object is a VM::EC2::ElasticAddress.
.ie n .SS "$boolean = $ec2\->release_address($addr)"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->release_address($addr)"
.IX Subsection "$boolean = $ec2->release_address($addr)"
Release an elastic \s-1IP\s0 address. For non-VPC addresses, you may provide
either an \s-1IP\s0 address string, or a VM::EC2::ElasticAddress. For \s-1VPC\s0
addresses, you must obtain a VM::EC2::ElasticAddress first 
(e.g. with describe_addresses) and then pass that to the method.
.ie n .SS "$result = $ec2\->associate_address($elastic_addr => $instance_id)"
.el .SS "\f(CW$result\fP = \f(CW$ec2\fP\->associate_address($elastic_addr => \f(CW$instance_id\fP)"
.IX Subsection "$result = $ec2->associate_address($elastic_addr => $instance_id)"
Associate an elastic address with an instance id. Both arguments are
mandatory. If you are associating a \s-1VPC\s0 elastic \s-1IP\s0 address with the
instance, the result code will indicate the associationId. Otherwise
it will be a simple perl truth value (\*(L"1\*(R") if successful, undef if
false.
.PP
If this is an ordinary \s-1EC2\s0 Elastic \s-1IP\s0 address, the first argument may
either be an ordinary string (xx.xx.xx.xx format) or a
VM::EC2::ElasticAddress object. However, if it is a \s-1VPC\s0 elastic
\&\s-1IP\s0 address, then the argument must be a VM::EC2::ElasticAddress
as returned by \fIdescribe_addresses()\fR. The reason for this is that the
allocationId must be retrieved from the object in order to use in the
call.
.ie n .SS "$bool = $ec2\->disassociate_address($elastic_addr)"
.el .SS "\f(CW$bool\fP = \f(CW$ec2\fP\->disassociate_address($elastic_addr)"
.IX Subsection "$bool = $ec2->disassociate_address($elastic_addr)"
Disassociate an elastic address from whatever instance it is currently
associated with, if any. The result will be true if disassociation was
successful.
.PP
If this is an ordinary \s-1EC2\s0 Elastic \s-1IP\s0 address, the argument may
either be an ordinary string (xx.xx.xx.xx format) or a
VM::EC2::ElasticAddress object. However, if it is a \s-1VPC\s0 elastic
\&\s-1IP\s0 address, then the argument must be a VM::EC2::ElasticAddress
as returned by \fIdescribe_addresses()\fR. The reason for this is that the
allocationId must be retrieved from the object in order to use in the
call.
.SH "RESERVED INSTANCES"
.IX Header "RESERVED INSTANCES"
These methods apply to describing, purchasing and using Reserved Instances.
.ie n .SS "@offerings = $ec2\->describe_reserved_instances_offerings(@offering_ids)"
.el .SS "\f(CW@offerings\fP = \f(CW$ec2\fP\->describe_reserved_instances_offerings(@offering_ids)"
.IX Subsection "@offerings = $ec2->describe_reserved_instances_offerings(@offering_ids)"
.ie n .SS "@offerings = $ec2\->describe_reserved_instances_offerings(%args)"
.el .SS "\f(CW@offerings\fP = \f(CW$ec2\fP\->describe_reserved_instances_offerings(%args)"
.IX Subsection "@offerings = $ec2->describe_reserved_instances_offerings(%args)"
This method returns a list of the reserved instance offerings
currently available for purchase. The arguments allow you to filter
the offerings according to a variety of filters.
.PP
All arguments are optional. If no named arguments are used, then the
arguments are treated as Reserved Instance Offering IDs.
.PP
.Vb 2
\& \-reserved_instances_offering_id  A scalar or arrayref of reserved
\&                                   instance offering IDs
\&
\& \-instance_type                   The instance type on which the
\&                                   reserved instance can be used,
\&                                   e.g. "c1.medium"
\&
\& \-availability_zone, \-zone        The availability zone in which the
\&                                   reserved instance can be used.
\&
\& \-product_description             The reserved instance description.
\&                                   Valid values are "Linux/UNIX",
\&                                   "Linux/UNIX (Amazon VPC)",
\&                                   "Windows", and "Windows (Amazon
\&                                   VPC)"
\&
\& \-instance_tenancy                The tenancy of the reserved instance
\&                                   offering, either "default" or
\&                                   "dedicated". (VPC instances only)
\&
\& \-filter                          A set of filters to apply.
.Ve
.PP
For available filters, see http://docs.amazonwebservices.com/AWSEC2/2011\-05\-15/APIReference/ApiReference\-query\-DescribeReservedInstancesOfferings.html.
.PP
The returned objects are of type VM::EC2::ReservedInstance::Offering
.PP
This can be combined with the Offering \fIpurchase()\fR method as shown here:
.PP
.Vb 7
\& @offerings = $ec2\->describe_reserved_instances_offerings(
\&          {\*(Aqavailability\-zone\*(Aq   => \*(Aqus\-east\-1a\*(Aq,
\&           \*(Aqinstance\-type\*(Aq       => \*(Aqc1.medium\*(Aq,
\&           \*(Aqproduct\-description\*(Aq =>\*(AqLinux/UNIX\*(Aq,
\&           \*(Aqduration\*(Aq            => 31536000,  # this is 1 year
\&           });
\& $offerings[0]\->purchase(5) and print "Five reserved instances purchased\en";
.Ve
.PP
Purchase one or more reserved instances based on an offering.
.PP
Arguments:
.PP
.Vb 2
\& \-reserved_instances_offering_id, \-id \-\- The reserved instance offering ID
\&                                         to purchase (required).
\&
\& \-instance_count, \-count              \-\- Number of instances to reserve
\&                                          under this offer (optional, defaults
\&                                          to 1).
.Ve
.PP
Returns a Reserved Instances Id on success, undef on failure. Also see the \fIpurchase()\fR method of
VM::EC2::ReservedInstance::Offering.
.ie n .SS "@res_instances = $ec2\->describe_reserved_instances(@res_instance_ids)"
.el .SS "\f(CW@res_instances\fP = \f(CW$ec2\fP\->describe_reserved_instances(@res_instance_ids)"
.IX Subsection "@res_instances = $ec2->describe_reserved_instances(@res_instance_ids)"
.ie n .SS "@res_instances = $ec2\->describe_reserved_instances(%args)"
.el .SS "\f(CW@res_instances\fP = \f(CW$ec2\fP\->describe_reserved_instances(%args)"
.IX Subsection "@res_instances = $ec2->describe_reserved_instances(%args)"
This method returns a list of the reserved instances that you
currently own.  The information returned includes the type of
instances that the reservation allows you to launch, the availability
zone, and the cost per hour to run those reserved instances.
.PP
All arguments are optional. If no named arguments are used, then the
arguments are treated as Reserved Instance  IDs.
.PP
.Vb 2
\& \-reserved_instances_id \-\- A scalar or arrayref of reserved
\&                            instance IDs
\&
\& \-filter                \-\- A set of filters to apply.
.Ve
.PP
For available filters, see http://docs.amazonwebservices.com/AWSEC2/2011\-05\-15/APIReference/ApiReference\-query\-DescribeReservedInstances.html.
.PP
The returned objects are of type VM::EC2::ReservedInstance
.SH "SPOT INSTANCES"
.IX Header "SPOT INSTANCES"
These methods allow you to request spot instances and manipulte spot
data feed subscriptoins.
.ie n .SS "$subscription = $ec2\->create_spot_datafeed_subscription($bucket,$prefix)"
.el .SS "\f(CW$subscription\fP = \f(CW$ec2\fP\->create_spot_datafeed_subscription($bucket,$prefix)"
.IX Subsection "$subscription = $ec2->create_spot_datafeed_subscription($bucket,$prefix)"
This method creates a spot datafeed subscription. Provide the method with the
name of an S3 bucket associated with your account, and a prefix to be appended
to the files written by the datafeed. Spot instance usage logs will be written 
into the requested bucket, and prefixed with the desired prefix.
.PP
If no prefix is specified, it defaults to \*(L"\s-1SPOT_DATAFEED_\s0\*(R";
.PP
On success, a VM::EC2::Spot:DatafeedSubscription object is returned;
.PP
Only one datafeed is allowed per account;
.ie n .SS "$boolean = $ec2\->\fIdelete_spot_datafeed_subscription()\fP"
.el .SS "\f(CW$boolean\fP = \f(CW$ec2\fP\->\fIdelete_spot_datafeed_subscription()\fP"
.IX Subsection "$boolean = $ec2->delete_spot_datafeed_subscription()"
This method delete's the current account's spot datafeed
subscription, if any. It takes no arguments.
.PP
On success, it returns true.
.ie n .SS "$subscription = $ec2\->\fIdescribe_spot_datafeed_subscription()\fP"
.el .SS "\f(CW$subscription\fP = \f(CW$ec2\fP\->\fIdescribe_spot_datafeed_subscription()\fP"
.IX Subsection "$subscription = $ec2->describe_spot_datafeed_subscription()"
This method describes the current account's spot datafeed
subscription, if any. It takes no arguments.
.PP
On success, a VM::EC2::Spot:DatafeedSubscription object is returned;
.ie n .SS "@spot_price_history = $ec2\->describe_spot_price_history(@filters)"
.el .SS "\f(CW@spot_price_history\fP = \f(CW$ec2\fP\->describe_spot_price_history(@filters)"
.IX Subsection "@spot_price_history = $ec2->describe_spot_price_history(@filters)"
This method applies the specified filters to spot instances and
returns a list of instances, timestamps and their price at the
indicated time. Each spot price history point is represented as a
VM::EC2::Spot::PriceHistory object.
.PP
Option parameters are:
.PP
.Vb 4
\& \-start_time      Start date and time of the desired history
\&                  data, in the form yyyy\-mm\-ddThh:mm:ss (GMT).
\&                  The Perl DateTime module provides a convenient
\&                  way to create times in this format.
\&
\& \-end_time        End date and time of the desired history
\&                  data.
\&
\& \-instance_type   The instance type, e.g. "m1.small", can be
\&                  a scalar value or an arrayref.
\&
\& \-product_description  The product description. One of "Linux/UNIX",
\&                  "SUSE Linux"  or "Windows". Can be a scalar value
\&                  or an arrayref.
\&
\& \-availability_zone A single availability zone, such as "us\-east\-1a".
\&
\& \-max_results     Maximum number of rows to return in a single
\&                  call.
\&
\& \-next_token      Specifies the next set of results to return; used
\&                  internally.
\&
\& \-filter          Hashref containing additional filters to apply,
.Ve
.PP
The following filters are recognized: \*(L"instance-type\*(R",
\&\*(L"product-description\*(R", \*(L"spot-price\*(R", \*(L"timestamp\*(R",
\&\*(L"availability-zone\*(R". The '*' and '?' wildcards can be used in filter
values, but numeric comparison operations are not supported by the
Amazon \s-1API\s0. Note that wildcards are not generally allowed in the
standard options. Hence if you wish to get spot price history in all
availability zones in us-east, this will work:
.PP
.Vb 1
\& $ec2\->describe_spot_price_history(\-filter=>{\*(Aqavailability\-zone\*(Aq=>\*(Aqus\-east*\*(Aq})
.Ve
.PP
but this will return an invalid parameter error:
.PP
.Vb 1
\& $ec2\->describe_spot_price_history(\-availability_zone=>\*(Aqus\-east*\*(Aq)
.Ve
.PP
If you specify \-max_results, then the list of history objects returned
may not represent the complete result set. In this case, the method
\&\fImore_spot_prices()\fR will return true. You can then call
\&\fIdescribe_spot_price_history()\fR repeatedly with no arguments in order to
retrieve the remainder of the results. When there are no more results,
\&\fImore_spot_prices()\fR will return false.
.PP
.Vb 9
\& my @results = $ec2\->describe_spot_price_history(\-max_results       => 20,
\&                                                 \-instance_type     => \*(Aqm1.small\*(Aq,
\&                                                 \-availability_zone => \*(Aqus\-east*\*(Aq,
\&                                                 \-product_description=>\*(AqLinux/UNIX\*(Aq);
\& print_history(\e@results);
\& while ($ec2\->more_spot_prices) {
\&    @results = $ec2\->describe_spot_price_history
\&    print_history(\e@results);
\& }
.Ve
.ie n .SS "@requests = $ec2\->request_spot_instances(%param)"
.el .SS "\f(CW@requests\fP = \f(CW$ec2\fP\->request_spot_instances(%param)"
.IX Subsection "@requests = $ec2->request_spot_instances(%param)"
This method will request one or more spot instances to be launched
when the current spot instance run-hour price drops below a preset
value and terminated when the spot instance run-hour price exceeds the
value.
.PP
On success, will return a series of VM::EC2::Spot::InstanceRequest
objects, one for each instance specified in \-instance_count.
.IP "Required parameters:" 4
.IX Item "Required parameters:"
.Vb 1
\&  \-spot_price        The desired spot price, in USD.
\&
\&  \-image_id          ID of an AMI to launch
\&
\&  \-instance_type     Type of the instance(s) to launch, such as "m1.small"
.Ve
.IP "Optional parameters:" 4
.IX Item "Optional parameters:"
.Vb 1
\&  \-instance_count    Maximum number of instances to launch (default 1)
\&
\&  \-type              Spot instance request type; one of "one\-time" or "persistent"
\&
\&  \-valid_from        Date/time the request becomes effective, in format
\&                       yyyy\-mm\-ddThh:mm:ss. Default is immediately.
\&
\&  \-valid_until       Date/time the request expires, in format 
\&                       yyyy\-mm\-ddThh:mm:ss. Default is to remain in
\&                       effect indefinitely.
\&
\&  \-launch_group      Name of the launch group. Instances in the same
\&                       launch group are started and terminated together.
\&                       Default is to launch instances independently.
\&
\&  \-availability_zone_group  If specified, all instances that are given
\&                       the same zone group name will be launched into the 
\&                       same availability zone. This is independent of
\&                       the \-availability_zone argument, which specifies
\&                       a particular availability zone.
\&
\&  \-key_name          Name of the keypair to use
\&
\&  \-security_group_id Security group ID to use for this instance.
\&                     Use an arrayref for multiple group IDs
\&
\&  \-security_group    Security group name to use for this instance.
\&                     Use an arrayref for multiple values.
\&
\&  \-user_data         User data to pass to the instances. Do NOT base64
\&                     encode this. It will be done for you.
\&
\&  \-availability_zone The availability zone you want to launch the
\&                     instance into. Call $ec2\->regions for a list.
\&  \-zone              Short version of \-availability_aone.
\&
\&  \-placement_group   An existing placement group to launch the
\&                     instance into. Applicable to cluster instances
\&                     only.
\&  \-placement_tenancy Specify \*(Aqdedicated\*(Aq to launch the instance on a
\&                     dedicated server. Only applicable for VPC
\&                     instances.
\&
\&  \-kernel_id         ID of the kernel to use for the instances,
\&                     overriding the kernel specified in the image.
\&
\&  \-ramdisk_id        ID of the ramdisk to use for the instances,
\&                     overriding the ramdisk specified in the image.
\&
\&  \-block_devices     Specify block devices to map onto the instances,
\&                     overriding the values specified in the image.
\&                     See run_instances() for the syntax of this argument.
\&
\&  \-block_device_mapping  Alias for \-block_devices.
\&
\&  \-monitoring        Pass a true value to enable detailed monitoring.
\&
\&  \-subnet_id         Subnet ID in which to place instances launched under
\&                      this request (VPC only).
\&
\&  \-addressing_type   Deprecated and undocumented, but present in the
\&                       current EC2 API documentation.
.Ve
.ie n .SS "@requests = $ec2\->cancel_spot_instance_requests(@request_ids)"
.el .SS "\f(CW@requests\fP = \f(CW$ec2\fP\->cancel_spot_instance_requests(@request_ids)"
.IX Subsection "@requests = $ec2->cancel_spot_instance_requests(@request_ids)"
This method cancels the pending requests. It does not terminate any
instances that are already running as a result of the requests. It
returns a list of VM::EC2::Spot::InstanceRequest objects, whose fields
will be unpopulated except for spotInstanceRequestId and state.
.ie n .SS "@requests = $ec2\->describe_spot_instance_requests(\-spot_instance_request_id=>\e@ids,\-filter=>\e%filters)"
.el .SS "\f(CW@requests\fP = \f(CW$ec2\fP\->describe_spot_instance_requests(\-spot_instance_request_id=>\e@ids,\-filter=>\e%filters)"
.IX Subsection "@requests = $ec2->describe_spot_instance_requests(-spot_instance_request_id=>@ids,-filter=>%filters)"
.ie n .SS "@requests = $ec2\->describe_spot_instance_requests(@spot_instance_request_ids)"
.el .SS "\f(CW@requests\fP = \f(CW$ec2\fP\->describe_spot_instance_requests(@spot_instance_request_ids)"
.IX Subsection "@requests = $ec2->describe_spot_instance_requests(@spot_instance_request_ids)"
.ie n .SS "@requests = $ec2\->describe_spot_instance_requests(\e%filters)"
.el .SS "\f(CW@requests\fP = \f(CW$ec2\fP\->describe_spot_instance_requests(\e%filters)"
.IX Subsection "@requests = $ec2->describe_spot_instance_requests(%filters)"
This method will return information about current spot instance
requests as a list of VM::EC2::Spot::InstanceRequest objects.
.PP
Optional parameters:
.PP
.Vb 1
\& \-spot_instance_request_id   \-\- Scalar or arrayref of request Ids.
\&
\& \-filter                     \-\- Tags and other filters to apply.
.Ve
.PP
There are many filters available, described fully at http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/index.html?ApiReference\-ItemType\-SpotInstanceRequestSetItemType.html:
.PP
.Vb 10
\&    availability\-zone\-group
\&    create\-time
\&    fault\-code
\&    fault\-message
\&    instance\-id
\&    launch\-group
\&    launch.block\-device\-mapping.delete\-on\-termination
\&    launch.block\-device\-mapping.device\-name
\&    launch.block\-device\-mapping.snapshot\-id
\&    launch.block\-device\-mapping.volume\-size
\&    launch.group\-id
\&    launch.image\-id
\&    launch.instance\-type
\&    launch.kernel\-id
\&    launch.key\-name
\&    launch.monitoring\-enabled
\&    launch.ramdisk\-id
\&    product\-description
\&    spot\-instance\-request\-id
\&    spot\-price
\&    state
\&    tag\-key
\&    tag\-value
\&    tag:<key>
\&    type
\&    launched\-availability\-zone
\&    valid\-from
\&    valid\-until
.Ve
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
These methods are used internally and are listed here without
documentation (yet).
.ie n .SS "$underscore_name = $ec2\->canonicalize($mixedCaseName)"
.el .SS "\f(CW$underscore_name\fP = \f(CW$ec2\fP\->canonicalize($mixedCaseName)"
.IX Subsection "$underscore_name = $ec2->canonicalize($mixedCaseName)"
.ie n .SS "$instance_id = $ec2\->instance_parm(@args)"
.el .SS "\f(CW$instance_id\fP = \f(CW$ec2\fP\->instance_parm(@args)"
.IX Subsection "$instance_id = $ec2->instance_parm(@args)"
.ie n .SS "@parameters = $ec2\->value_parm(ParameterName => \e%args)"
.el .SS "\f(CW@parameters\fP = \f(CW$ec2\fP\->value_parm(ParameterName => \e%args)"
.IX Subsection "@parameters = $ec2->value_parm(ParameterName => %args)"
.ie n .SS "@parameters = $ec2\->single_parm(ParameterName => \e%args)"
.el .SS "\f(CW@parameters\fP = \f(CW$ec2\fP\->single_parm(ParameterName => \e%args)"
.IX Subsection "@parameters = $ec2->single_parm(ParameterName => %args)"
.ie n .SS "@parameters = $ec2\->list_parm(ParameterName => \e%args)"
.el .SS "\f(CW@parameters\fP = \f(CW$ec2\fP\->list_parm(ParameterName => \e%args)"
.IX Subsection "@parameters = $ec2->list_parm(ParameterName => %args)"
.ie n .SS "@parameters = $ec2\->filter_parm(\e%args)"
.el .SS "\f(CW@parameters\fP = \f(CW$ec2\fP\->filter_parm(\e%args)"
.IX Subsection "@parameters = $ec2->filter_parm(%args)"
.ie n .SS "@parameters = $ec2\->tagcreate_parm(\e%args)"
.el .SS "\f(CW@parameters\fP = \f(CW$ec2\fP\->tagcreate_parm(\e%args)"
.IX Subsection "@parameters = $ec2->tagcreate_parm(%args)"
.ie n .SS "@parameters = $ec2\->tagdelete_parm(\e%args)"
.el .SS "\f(CW@parameters\fP = \f(CW$ec2\fP\->tagdelete_parm(\e%args)"
.IX Subsection "@parameters = $ec2->tagdelete_parm(%args)"
.ie n .SS "@parameters = $ec2\->key_value_parm($param_name,$keyname,$valuename,\e%args,$skip_undef_values)"
.el .SS "\f(CW@parameters\fP = \f(CW$ec2\fP\->key_value_parm($param_name,$keyname,$valuename,\e%args,$skip_undef_values)"
.IX Subsection "@parameters = $ec2->key_value_parm($param_name,$keyname,$valuename,%args,$skip_undef_values)"
.ie n .SS "@parameters = $ec2\->launch_perm_parm($prefix,$suffix,$value)"
.el .SS "\f(CW@parameters\fP = \f(CW$ec2\fP\->launch_perm_parm($prefix,$suffix,$value)"
.IX Subsection "@parameters = $ec2->launch_perm_parm($prefix,$suffix,$value)"
.ie n .SS "@parameters = $ec2\->block_device_parm($block_device_mapping_string)"
.el .SS "\f(CW@parameters\fP = \f(CW$ec2\fP\->block_device_parm($block_device_mapping_string)"
.IX Subsection "@parameters = $ec2->block_device_parm($block_device_mapping_string)"
.ie n .SS "$version = $ec2\->\fIversion()\fP"
.el .SS "\f(CW$version\fP = \f(CW$ec2\fP\->\fIversion()\fP"
.IX Subsection "$version = $ec2->version()"
\&\s-1API\s0 version.
.ie n .SS "$ts = $ec2\->timestamp"
.el .SS "\f(CW$ts\fP = \f(CW$ec2\fP\->timestamp"
.IX Subsection "$ts = $ec2->timestamp"
.ie n .SS "$ua = $ec2\->ua"
.el .SS "\f(CW$ua\fP = \f(CW$ec2\fP\->ua"
.IX Subsection "$ua = $ec2->ua"
LWP::UserAgent object.
.ie n .SS "@obj = $ec2\->call($action,@param);"
.el .SS "\f(CW@obj\fP = \f(CW$ec2\fP\->call($action,@param);"
.IX Subsection "@obj = $ec2->call($action,@param);"
Make a call to Amazon using \f(CW$action\fR and the passed parameters, and
return a list of objects.
.ie n .SS "$request = $ec2\->make_request($action,@param);"
.el .SS "\f(CW$request\fP = \f(CW$ec2\fP\->make_request($action,@param);"
.IX Subsection "$request = $ec2->make_request($action,@param);"
Set up the signed HTTP::Request object.
.ie n .SS "$request = $ec2\->_sign(@args)"
.el .SS "\f(CW$request\fP = \f(CW$ec2\fP\->_sign(@args)"
.IX Subsection "$request = $ec2->_sign(@args)"
Create and sign an HTTP::Request.
.ie n .SS "@param = $ec2\->args(ParamName=>@_)"
.el .SS "\f(CW@param\fP = \f(CW$ec2\fP\->args(ParamName=>@_)"
.IX Subsection "@param = $ec2->args(ParamName=>@_)"
Set up calls that take either method(\-resource_id=>'foo') or method('foo').
.SH "MISSING METHODS"
.IX Header "MISSING METHODS"
As of 27 July 2011, the following Amazon \s-1API\s0 calls were \s-1NOT\s0 implemented:
.PP
AssociateDhcpOptions
AssociateRouteTable
AttachInternetGateway
AttachVpnGateway
BundleInstance
CancelBundleTask
CancelConversionTask
CancelSpotInstanceRequests
ConfirmProductInstance
CreateCustomerGateway
CreateDhcpOptions
CreateInternetGateway
CreateNetworkAcl
CreateNetworkAclEntry
CreatePlacementGroup
CreateRoute
CreateRouteTable
CreateSpotDatafeedSubscription
CreateSubnet
CreateVpc
CreateVpnConnection
CreateVpnGateway
DeleteCustomerGateway
DeleteDhcpOptions
DeleteInternetGateway
DeleteNetworkAcl
DeleteNetworkAclEntry
DeletePlacementGroup
DeleteRoute
DeleteRouteTable
DeleteSpotDatafeedSubscription
DeleteSubnet
DeleteVpc
DeleteVpnConnection
DeleteVpnGateway
DescribeBundleTasks
DescribeConversionTasks
DescribeCustomerGateways
DescribeDhcpOptions
DescribeNetworkAcls
DescribePlacementGroups
DescribeRouteTables
DescribeSpotDatafeedSubscription
DescribeSpotInstanceRequests
DescribeSpotPriceHistory
DescribeSubnets
DescribeVpcs
DescribeVpnConnections
DescribeVpnGateways
DetachInternetGateway
DetachVpnGateway
DisassociateRouteTable
ImportInstance
ReplaceNetworkAclAssociation
ReplaceNetworkAclEntry
ReplaceRoute
ReplaceRouteTableAssociation
RequestSpotInstances
.SH "OTHER INFORMATION"
.IX Header "OTHER INFORMATION"
This section contains technical information that may be of interest to developers.
.SS "Signing and authentication protocol"
.IX Subsection "Signing and authentication protocol"
This module uses Amazon \s-1AWS\s0 signing protocol version 2, as described
at
http://docs.amazonwebservices.com/AWSEC2/latest/UserGuide/index.html?using\-query\-api.html. It
uses the HmacSHA256 signature method, which is the most secure method
currently available. For additional security, use \*(L"https\*(R" for the
communications endpoint:
.PP
.Vb 1
\&  $ec2 = VM::EC2\->new(\-endpoint=>\*(Aqhttps://ec2.amazonaws.com\*(Aq);
.Ve
.SS "Subclassing \s-1VM::EC2\s0 objects"
.IX Subsection "Subclassing VM::EC2 objects"
To subclass \s-1VM::EC2\s0 objects (or implement your own from scratch) you
will need to override the object dispatch mechanism. Fortunately this
is very easy. After \*(L"use \s-1VM::EC2\s0\*(R" call
VM::EC2::Dispatch\->\fIadd_override()\fR one or more times:
.PP
.Vb 1
\& VM::EC2::Dispatch\->add_override($call_name => $dispatch).
.Ve
.PP
The first argument, \f(CW$call_name\fR, is name of the Amazon \s-1API\s0 call, such as \*(L"DescribeImages\*(R".
.PP
The second argument, \f(CW$dispatch\fR, instructs VM::EC2::Dispatch how to
create objects from the parsed \s-1XML\s0. There are three possible syntaxes:
.PP
.Vb 1
\& 1) A CODE references, such as an anonymous subroutine.
\&
\&    In this case the code reference will be invoked to handle the 
\&    parsed XML returned from the request. The code will receive 
\&    two arguments consisting of the parsed
\&    content of the response, and the VM::EC2 object used to generate the
\&    request.
\&
\& 2) A VM::EC2::Dispatch method name, optionally followed by its parameters
\&    delimited by commas. Example:
\&
\&           "fetch_items,securityGroupInfo,VM::EC2::SecurityGroup"
\&
\&    This tells Dispatch to invoke its fetch_items() method with
\&    the following arguments:
\&
\&     $dispatch\->fetch_items($parsed_xml,$ec2,\*(AqsecurityGroupInfo\*(Aq,\*(AqVM::EC2::SecurityGroup\*(Aq)
\&
\&    The fetch_items() method is used for responses in which a
\&    list of objects is embedded within a series of <item> tags.
\&    See L<VM::EC2::Dispatch> for more information.
\&
\&    Other commonly\-used methods are "fetch_one", and "boolean".
\&
\& 3) A class name, such as \*(AqMyVolume\*(Aq
\&
\&    In this case, class MyVolume is loaded and then its new() method
\&    is called with the four arguments ($parsed_xml,$ec2,$xmlns,$requestid),
\&    where $parsed_xml is the parsed XML response, $ec2 is the VM::EC2
\&    object that generated the request, $xmlns is the XML namespace
\&    of the XML response, and $requestid is the AWS\-generated ID for the
\&    request. Only the first two arguments are really useful.
\&
\&    I suggest you inherit from VM::EC2::Generic and use the inherited new()
\&    method to store the parsed XML object and other arguments.
.Ve
.PP
Dispatch tries each of (1), (2) and (3), in order. This means that
class names cannot collide with method names.
.PP
The parsed content is the result of passing the raw \s-1XML\s0 through a
XML::Simple object created with:
.PP
.Vb 3
\& XML::Simple\->new(ForceArray    => [\*(Aqitem\*(Aq],
\&                  KeyAttr       => [\*(Aqkey\*(Aq],
\&                  SuppressEmpty => undef);
.Ve
.PP
In general, this will give you a hash of hashes. Any tag named 'item'
will be forced to point to an array reference, and any tag named \*(L"key\*(R"
will be flattened as described in the XML::Simple documentation.
.PP
A simple way to examine the raw parsed \s-1XML\s0 is to invoke any
VM::EC2::Generic's \fIas_string()\fR method:
.PP
.Vb 2
\& my ($i) = $ec2\->describe_instances;
\& print $i\->as_string;
.Ve
.PP
This will give you a Data::Dumper representation of the \s-1XML\s0 after it
has been parsed.
.PP
The suggested way to override the dispatch table is from within a
subclass of \s-1VM::EC2:\s0
.PP
.Vb 8
\& package \*(AqVM::EC2New\*(Aq;
\& use base \*(AqVM::EC2\*(Aq;
\&  sub new {
\&      my $self=shift;
\&      VM::EC2::Dispatch\->add_override(\*(Aqcall_name_1\*(Aq=>\e&subroutine1).
\&      VM::EC2::Dispatch\->add_override(\*(Aqcall_name_2\*(Aq=>\e&subroutine2).
\&      $self\->SUPER::new(@_);
\& }
.Ve
.PP
See VM::EC2::Dispatch for a working example of subclassing \s-1VM::EC2\s0
and one of its object classes.
.SH "DEVELOPING"
.IX Header "DEVELOPING"
The git source for this library can be found at https://github.com/lstein/LibVM\-EC2\-Perl,
To contribute to development, please obtain a github account and then either:
.PP
.Vb 2
\& 1) Fork a copy of the repository, make your changes against this repository, 
\&    and send a pull request to me to incorporate your changes.
\&
\& 2) Contact me by email and ask for push privileges on the repository.
.Ve
.PP
See http://help.github.com/ for help getting started.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::Amazon::EC2
VM::EC2::Dispatch
VM::EC2::Generic
VM::EC2::BlockDevice
VM::EC2::BlockDevice::Attachment
VM::EC2::BlockDevice::EBS
VM::EC2::BlockDevice::Mapping
VM::EC2::BlockDevice::Mapping::EBS
VM::EC2::Error
VM::EC2::Generic
VM::EC2::Group
VM::EC2::Image
VM::EC2::Instance
VM::EC2::Instance::ConsoleOutput
VM::EC2::Instance::Metadata
VM::EC2::Instance::MonitoringState
VM::EC2::Instance::PasswordData
VM::EC2::Instance::Set
VM::EC2::Instance::State
VM::EC2::Instance::State::Change
VM::EC2::Instance::State::Reason
VM::EC2::KeyPair
VM::EC2::Region
VM::EC2::ReservationSet
VM::EC2::ReservedInstance
VM::EC2::ReservedInstance::Offering
VM::EC2::SecurityGroup
VM::EC2::Snapshot
VM::EC2::Tag
VM::EC2::Volume
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lincoln.stein@gmail.com>.
.PP
Copyright (c) 2011 Ontario Institute for Cancer Research
.PP
This package and its accompanying libraries is free software; you can
redistribute it and/or modify it under the terms of the \s-1GPL\s0 (either
version 1, or at your option, any later version) or the Artistic
License 2.0.  Refer to \s-1LICENSE\s0 for the full license text. In addition,
please see \s-1DISCLAIMER\s0.txt for disclaimers of warranty.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 2618:" 4
.IX Item "Around line 2618:"
Unknown directive: =head
.IP "Around line 2620:" 4
.IX Item "Around line 2620:"
Unknown directive: =head
.IP "Around line 2964:" 4
.IX Item "Around line 2964:"
You forgot a '=back' before '=head2'
